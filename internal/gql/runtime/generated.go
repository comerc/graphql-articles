// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package runtime

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/url"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/acelot/articles/internal/gql/model"
	"github.com/google/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Article() ArticleResolver
	ArticleBlockFindList() ArticleBlockFindListResolver
	ArticleBlockImageData() ArticleBlockImageDataResolver
	ArticleBlockMutation() ArticleBlockMutationResolver
	ArticleBlockQuery() ArticleBlockQueryResolver
	ArticleFindList() ArticleFindListResolver
	ArticleMutation() ArticleMutationResolver
	ArticleQuery() ArticleQueryResolver
	ArticleTag() ArticleTagResolver
	ArticleTagMutation() ArticleTagMutationResolver
	Image() ImageResolver
	ImageFindList() ImageFindListResolver
	ImageMutation() ImageMutationResolver
	ImageQuery() ImageQueryResolver
	Mutation() MutationResolver
	ProjectFindList() ProjectFindListResolver
	ProjectMutation() ProjectMutationResolver
	ProjectQuery() ProjectQueryResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	TagFindList() TagFindListResolver
	TagMutation() TagMutationResolver
	TagQuery() TagQueryResolver
}

type DirectiveRoot struct {
	InputUnion    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	SortRankInput func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Article struct {
		Content      func(childComplexity int) int
		CoverImage   func(childComplexity int) int
		CoverImageID func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		ModifiedAt   func(childComplexity int) int
		Project      func(childComplexity int) int
		ProjectID    func(childComplexity int) int
		Tags         func(childComplexity int) int
		Title        func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	ArticleBlockCreateOk struct {
		ArticleBlock func(childComplexity int) int
	}

	ArticleBlockFindList struct {
		Items      func(childComplexity int) int
		TotalCount func(childComplexity int, estimate uint) int
	}

	ArticleBlockHtml struct {
		CreatedAt  func(childComplexity int) int
		Data       func(childComplexity int) int
		DeletedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		ModifiedAt func(childComplexity int) int
		SortRank   func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	ArticleBlockHtmlData struct {
		Body func(childComplexity int) int
	}

	ArticleBlockImage struct {
		CreatedAt  func(childComplexity int) int
		Data       func(childComplexity int) int
		DeletedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		ModifiedAt func(childComplexity int) int
		SortRank   func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	ArticleBlockImageData struct {
		Copyright   func(childComplexity int) int
		Description func(childComplexity int) int
		Image       func(childComplexity int) int
		ImageID     func(childComplexity int) int
	}

	ArticleBlockMoveOk struct {
		SortRank func(childComplexity int) int
		Version  func(childComplexity int) int
	}

	ArticleBlockMutation struct {
		Create func(childComplexity int, input model.ArticleBlockCreateInput) int
		Move   func(childComplexity int, input model.ArticleBlockMoveInput) int
		Update func(childComplexity int, input model.ArticleBlockUpdateInput) int
	}

	ArticleBlockNotFoundProblem struct {
		Message func(childComplexity int) int
	}

	ArticleBlockQuery struct {
		Find func(childComplexity int, filter *model.ArticleBlockFindFilterInput, sort model.ArticleBlockFindSortEnum, pageSize uint, pageNumber uint) int
	}

	ArticleBlockTypeMismatchProblem struct {
		Message func(childComplexity int) int
	}

	ArticleBlockUpdateOk struct {
		ArticleBlock func(childComplexity int) int
	}

	ArticleContent struct {
		Blocks func(childComplexity int) int
	}

	ArticleCreateOk struct {
		Article func(childComplexity int) int
	}

	ArticleFindList struct {
		Items      func(childComplexity int) int
		TotalCount func(childComplexity int, estimate uint) int
	}

	ArticleMutation struct {
		Create func(childComplexity int, input model.ArticleCreateInput) int
		Update func(childComplexity int, input model.ArticleUpdateInput) int
	}

	ArticleNotFoundProblem struct {
		Message func(childComplexity int) int
	}

	ArticleQuery struct {
		Find func(childComplexity int, filter *model.ArticleFindFilterInput, sort model.ArticleFindSortEnum, pageSize uint, pageNumber uint) int
	}

	ArticleTag struct {
		ArticleID  func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		ModifiedAt func(childComplexity int) int
		SortRank   func(childComplexity int) int
		Tag        func(childComplexity int) int
		TagID      func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	ArticleTagAlreadyExistsProblem struct {
		Message func(childComplexity int) int
	}

	ArticleTagCreateOk struct {
		ArticleTag func(childComplexity int) int
	}

	ArticleTagList struct {
		Items func(childComplexity int) int
	}

	ArticleTagMoveOk struct {
		SortRank func(childComplexity int) int
		Version  func(childComplexity int) int
	}

	ArticleTagMutation struct {
		Create func(childComplexity int, input model.ArticleTagCreateInput) int
		Move   func(childComplexity int, input model.ArticleTagMoveInput) int
	}

	ArticleTagNotFoundProblem struct {
		Message func(childComplexity int) int
	}

	ArticleUpdateOk struct {
		Article func(childComplexity int) int
	}

	Image struct {
		Assets     func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		DeletedAt  func(childComplexity int) int
		Download   func(childComplexity int) int
		Height     func(childComplexity int) int
		ID         func(childComplexity int) int
		ModifiedAt func(childComplexity int) int
		Type       func(childComplexity int) int
		Version    func(childComplexity int) int
		Width      func(childComplexity int) int
	}

	ImageAsset struct {
		Format func(childComplexity int) int
		URL    func(childComplexity int) int
		Width  func(childComplexity int) int
	}

	ImageDownload struct {
		URL func(childComplexity int) int
	}

	ImageFindList struct {
		Items      func(childComplexity int) int
		TotalCount func(childComplexity int, estimate uint) int
	}

	ImageMutation struct {
		Upload func(childComplexity int, input model.ImageUploadInput) int
	}

	ImageNotFoundProblem struct {
		Message func(childComplexity int) int
	}

	ImageNotRecognizedProblem struct {
		Message func(childComplexity int) int
	}

	ImageNotSupportedTypeProblem struct {
		Message func(childComplexity int) int
	}

	ImageQuery struct {
		Find func(childComplexity int, filter *model.ImageFindFilterInput, sort model.ImageFindSortEnum, pageSize uint, pageNumber uint) int
	}

	ImageUploadOk struct {
		Image func(childComplexity int) int
	}

	InternalErrorProblem struct {
		Message func(childComplexity int) int
	}

	InvalidSortRankProblem struct {
		Message func(childComplexity int) int
	}

	Mutation struct {
		Article      func(childComplexity int) int
		ArticleBlock func(childComplexity int) int
		ArticleTag   func(childComplexity int) int
		Image        func(childComplexity int) int
		Project      func(childComplexity int) int
		Tag          func(childComplexity int) int
	}

	Project struct {
		CreatedAt  func(childComplexity int) int
		DeletedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		ModifiedAt func(childComplexity int) int
		Name       func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	ProjectAlreadyExistsProblem struct {
		Message func(childComplexity int) int
	}

	ProjectCreateOk struct {
		Project func(childComplexity int) int
	}

	ProjectFindList struct {
		Items      func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ProjectMutation struct {
		Create func(childComplexity int, input model.ProjectCreateInput) int
		Update func(childComplexity int, input model.ProjectUpdateInput) int
	}

	ProjectNotFoundProblem struct {
		Message func(childComplexity int) int
	}

	ProjectQuery struct {
		Find func(childComplexity int, filter *model.ProjectFindFilterInput, sort model.ProjectFindSortEnum, pageSize uint, pageNumber uint) int
	}

	ProjectUpdateOk struct {
		Project func(childComplexity int) int
	}

	Query struct {
		Article      func(childComplexity int) int
		ArticleBlock func(childComplexity int) int
		Image        func(childComplexity int) int
		Project      func(childComplexity int) int
		Tag          func(childComplexity int) int
	}

	Subscription struct {
		ArticleBlockCreated func(childComplexity int, articleID uuid.UUID) int
	}

	Tag struct {
		CreatedAt  func(childComplexity int) int
		DeletedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		ModifiedAt func(childComplexity int) int
		Name       func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	TagAlreadyExistsProblem struct {
		Message func(childComplexity int) int
	}

	TagCreateOk struct {
		Tag func(childComplexity int) int
	}

	TagFindList struct {
		Items      func(childComplexity int) int
		TotalCount func(childComplexity int, estimate uint) int
	}

	TagMutation struct {
		Create func(childComplexity int, input model.TagCreateInput) int
		Update func(childComplexity int, input model.TagUpdateInput) int
	}

	TagNotFoundProblem struct {
		Message func(childComplexity int) int
	}

	TagQuery struct {
		Find func(childComplexity int, filter *model.TagFindFilterInput, sort model.TagFindSortEnum, pageSize uint, pageNumber uint) int
	}

	TagUpdateOk struct {
		Tag func(childComplexity int) int
	}

	TotalCount struct {
		Value func(childComplexity int) int
	}

	VersionMismatchProblem struct {
		Message func(childComplexity int) int
	}
}

type ArticleResolver interface {
	Content(ctx context.Context, obj *model.Article) (model.ArticleContentResolvingResult, error)
	CoverImage(ctx context.Context, obj *model.Article) (model.ImageResolvingResult, error)

	Project(ctx context.Context, obj *model.Article) (model.ProjectResolvingResult, error)

	Tags(ctx context.Context, obj *model.Article) (model.ArticleTagsResolvingResult, error)
}
type ArticleBlockFindListResolver interface {
	TotalCount(ctx context.Context, obj *model.ArticleBlockFindList, estimate uint) (model.TotalCountResolvingResult, error)
}
type ArticleBlockImageDataResolver interface {
	Image(ctx context.Context, obj *model.ArticleBlockImageData) (model.ImageResolvingResult, error)
}
type ArticleBlockMutationResolver interface {
	Create(ctx context.Context, obj *model.ArticleBlockMutation, input model.ArticleBlockCreateInput) (model.ArticleBlockCreateResult, error)
	Move(ctx context.Context, obj *model.ArticleBlockMutation, input model.ArticleBlockMoveInput) (model.ArticleBlockMoveResult, error)
	Update(ctx context.Context, obj *model.ArticleBlockMutation, input model.ArticleBlockUpdateInput) (model.ArticleBlockUpdateResult, error)
}
type ArticleBlockQueryResolver interface {
	Find(ctx context.Context, obj *model.ArticleBlockQuery, filter *model.ArticleBlockFindFilterInput, sort model.ArticleBlockFindSortEnum, pageSize uint, pageNumber uint) (model.ArticleBlockFindResult, error)
}
type ArticleFindListResolver interface {
	TotalCount(ctx context.Context, obj *model.ArticleFindList, estimate uint) (model.TotalCountResolvingResult, error)
}
type ArticleMutationResolver interface {
	Create(ctx context.Context, obj *model.ArticleMutation, input model.ArticleCreateInput) (model.ArticleCreateResult, error)
	Update(ctx context.Context, obj *model.ArticleMutation, input model.ArticleUpdateInput) (model.ArticleUpdateResult, error)
}
type ArticleQueryResolver interface {
	Find(ctx context.Context, obj *model.ArticleQuery, filter *model.ArticleFindFilterInput, sort model.ArticleFindSortEnum, pageSize uint, pageNumber uint) (model.ArticleFindResult, error)
}
type ArticleTagResolver interface {
	Tag(ctx context.Context, obj *model.ArticleTag) (model.TagResolvingResult, error)
}
type ArticleTagMutationResolver interface {
	Create(ctx context.Context, obj *model.ArticleTagMutation, input model.ArticleTagCreateInput) (model.ArticleTagCreateResult, error)
	Move(ctx context.Context, obj *model.ArticleTagMutation, input model.ArticleTagMoveInput) (model.ArticleTagMoveResult, error)
}
type ImageResolver interface {
	Assets(ctx context.Context, obj *model.Image) ([]*model.ImageAsset, error)

	Download(ctx context.Context, obj *model.Image) (model.ImageDownloadResolvingResult, error)
}
type ImageFindListResolver interface {
	TotalCount(ctx context.Context, obj *model.ImageFindList, estimate uint) (model.TotalCountResolvingResult, error)
}
type ImageMutationResolver interface {
	Upload(ctx context.Context, obj *model.ImageMutation, input model.ImageUploadInput) (model.ImageUploadResult, error)
}
type ImageQueryResolver interface {
	Find(ctx context.Context, obj *model.ImageQuery, filter *model.ImageFindFilterInput, sort model.ImageFindSortEnum, pageSize uint, pageNumber uint) (model.ImageFindResult, error)
}
type MutationResolver interface {
	ArticleBlock(ctx context.Context) (*model.ArticleBlockMutation, error)
	Article(ctx context.Context) (*model.ArticleMutation, error)
	ArticleTag(ctx context.Context) (*model.ArticleTagMutation, error)
	Image(ctx context.Context) (*model.ImageMutation, error)
	Project(ctx context.Context) (*model.ProjectMutation, error)
	Tag(ctx context.Context) (*model.TagMutation, error)
}
type ProjectFindListResolver interface {
	TotalCount(ctx context.Context, obj *model.ProjectFindList) (model.TotalCountResolvingResult, error)
}
type ProjectMutationResolver interface {
	Create(ctx context.Context, obj *model.ProjectMutation, input model.ProjectCreateInput) (model.ProjectCreateResult, error)
	Update(ctx context.Context, obj *model.ProjectMutation, input model.ProjectUpdateInput) (model.ProjectUpdateResult, error)
}
type ProjectQueryResolver interface {
	Find(ctx context.Context, obj *model.ProjectQuery, filter *model.ProjectFindFilterInput, sort model.ProjectFindSortEnum, pageSize uint, pageNumber uint) (model.ProjectFindResult, error)
}
type QueryResolver interface {
	ArticleBlock(ctx context.Context) (*model.ArticleBlockQuery, error)
	Article(ctx context.Context) (*model.ArticleQuery, error)
	Image(ctx context.Context) (*model.ImageQuery, error)
	Project(ctx context.Context) (*model.ProjectQuery, error)
	Tag(ctx context.Context) (*model.TagQuery, error)
}
type SubscriptionResolver interface {
	ArticleBlockCreated(ctx context.Context, articleID uuid.UUID) (<-chan model.ArticleBlockInterface, error)
}
type TagFindListResolver interface {
	TotalCount(ctx context.Context, obj *model.TagFindList, estimate uint) (model.TotalCountResolvingResult, error)
}
type TagMutationResolver interface {
	Create(ctx context.Context, obj *model.TagMutation, input model.TagCreateInput) (model.TagCreateResult, error)
	Update(ctx context.Context, obj *model.TagMutation, input model.TagUpdateInput) (model.TagUpdateResult, error)
}
type TagQueryResolver interface {
	Find(ctx context.Context, obj *model.TagQuery, filter *model.TagFindFilterInput, sort model.TagFindSortEnum, pageSize uint, pageNumber uint) (model.TagFindResult, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Article.content":
		if e.complexity.Article.Content == nil {
			break
		}

		return e.complexity.Article.Content(childComplexity), true

	case "Article.coverImage":
		if e.complexity.Article.CoverImage == nil {
			break
		}

		return e.complexity.Article.CoverImage(childComplexity), true

	case "Article.coverImageId":
		if e.complexity.Article.CoverImageID == nil {
			break
		}

		return e.complexity.Article.CoverImageID(childComplexity), true

	case "Article.createdAt":
		if e.complexity.Article.CreatedAt == nil {
			break
		}

		return e.complexity.Article.CreatedAt(childComplexity), true

	case "Article.deletedAt":
		if e.complexity.Article.DeletedAt == nil {
			break
		}

		return e.complexity.Article.DeletedAt(childComplexity), true

	case "Article.id":
		if e.complexity.Article.ID == nil {
			break
		}

		return e.complexity.Article.ID(childComplexity), true

	case "Article.modifiedAt":
		if e.complexity.Article.ModifiedAt == nil {
			break
		}

		return e.complexity.Article.ModifiedAt(childComplexity), true

	case "Article.project":
		if e.complexity.Article.Project == nil {
			break
		}

		return e.complexity.Article.Project(childComplexity), true

	case "Article.projectId":
		if e.complexity.Article.ProjectID == nil {
			break
		}

		return e.complexity.Article.ProjectID(childComplexity), true

	case "Article.tags":
		if e.complexity.Article.Tags == nil {
			break
		}

		return e.complexity.Article.Tags(childComplexity), true

	case "Article.title":
		if e.complexity.Article.Title == nil {
			break
		}

		return e.complexity.Article.Title(childComplexity), true

	case "Article.version":
		if e.complexity.Article.Version == nil {
			break
		}

		return e.complexity.Article.Version(childComplexity), true

	case "ArticleBlockCreateOk.articleBlock":
		if e.complexity.ArticleBlockCreateOk.ArticleBlock == nil {
			break
		}

		return e.complexity.ArticleBlockCreateOk.ArticleBlock(childComplexity), true

	case "ArticleBlockFindList.items":
		if e.complexity.ArticleBlockFindList.Items == nil {
			break
		}

		return e.complexity.ArticleBlockFindList.Items(childComplexity), true

	case "ArticleBlockFindList.totalCount":
		if e.complexity.ArticleBlockFindList.TotalCount == nil {
			break
		}

		args, err := ec.field_ArticleBlockFindList_totalCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleBlockFindList.TotalCount(childComplexity, args["estimate"].(uint)), true

	case "ArticleBlockHtml.createdAt":
		if e.complexity.ArticleBlockHtml.CreatedAt == nil {
			break
		}

		return e.complexity.ArticleBlockHtml.CreatedAt(childComplexity), true

	case "ArticleBlockHtml.data":
		if e.complexity.ArticleBlockHtml.Data == nil {
			break
		}

		return e.complexity.ArticleBlockHtml.Data(childComplexity), true

	case "ArticleBlockHtml.deletedAt":
		if e.complexity.ArticleBlockHtml.DeletedAt == nil {
			break
		}

		return e.complexity.ArticleBlockHtml.DeletedAt(childComplexity), true

	case "ArticleBlockHtml.id":
		if e.complexity.ArticleBlockHtml.ID == nil {
			break
		}

		return e.complexity.ArticleBlockHtml.ID(childComplexity), true

	case "ArticleBlockHtml.modifiedAt":
		if e.complexity.ArticleBlockHtml.ModifiedAt == nil {
			break
		}

		return e.complexity.ArticleBlockHtml.ModifiedAt(childComplexity), true

	case "ArticleBlockHtml.sortRank":
		if e.complexity.ArticleBlockHtml.SortRank == nil {
			break
		}

		return e.complexity.ArticleBlockHtml.SortRank(childComplexity), true

	case "ArticleBlockHtml.version":
		if e.complexity.ArticleBlockHtml.Version == nil {
			break
		}

		return e.complexity.ArticleBlockHtml.Version(childComplexity), true

	case "ArticleBlockHtmlData.body":
		if e.complexity.ArticleBlockHtmlData.Body == nil {
			break
		}

		return e.complexity.ArticleBlockHtmlData.Body(childComplexity), true

	case "ArticleBlockImage.createdAt":
		if e.complexity.ArticleBlockImage.CreatedAt == nil {
			break
		}

		return e.complexity.ArticleBlockImage.CreatedAt(childComplexity), true

	case "ArticleBlockImage.data":
		if e.complexity.ArticleBlockImage.Data == nil {
			break
		}

		return e.complexity.ArticleBlockImage.Data(childComplexity), true

	case "ArticleBlockImage.deletedAt":
		if e.complexity.ArticleBlockImage.DeletedAt == nil {
			break
		}

		return e.complexity.ArticleBlockImage.DeletedAt(childComplexity), true

	case "ArticleBlockImage.id":
		if e.complexity.ArticleBlockImage.ID == nil {
			break
		}

		return e.complexity.ArticleBlockImage.ID(childComplexity), true

	case "ArticleBlockImage.modifiedAt":
		if e.complexity.ArticleBlockImage.ModifiedAt == nil {
			break
		}

		return e.complexity.ArticleBlockImage.ModifiedAt(childComplexity), true

	case "ArticleBlockImage.sortRank":
		if e.complexity.ArticleBlockImage.SortRank == nil {
			break
		}

		return e.complexity.ArticleBlockImage.SortRank(childComplexity), true

	case "ArticleBlockImage.version":
		if e.complexity.ArticleBlockImage.Version == nil {
			break
		}

		return e.complexity.ArticleBlockImage.Version(childComplexity), true

	case "ArticleBlockImageData.copyright":
		if e.complexity.ArticleBlockImageData.Copyright == nil {
			break
		}

		return e.complexity.ArticleBlockImageData.Copyright(childComplexity), true

	case "ArticleBlockImageData.description":
		if e.complexity.ArticleBlockImageData.Description == nil {
			break
		}

		return e.complexity.ArticleBlockImageData.Description(childComplexity), true

	case "ArticleBlockImageData.image":
		if e.complexity.ArticleBlockImageData.Image == nil {
			break
		}

		return e.complexity.ArticleBlockImageData.Image(childComplexity), true

	case "ArticleBlockImageData.imageId":
		if e.complexity.ArticleBlockImageData.ImageID == nil {
			break
		}

		return e.complexity.ArticleBlockImageData.ImageID(childComplexity), true

	case "ArticleBlockMoveOk.sortRank":
		if e.complexity.ArticleBlockMoveOk.SortRank == nil {
			break
		}

		return e.complexity.ArticleBlockMoveOk.SortRank(childComplexity), true

	case "ArticleBlockMoveOk.version":
		if e.complexity.ArticleBlockMoveOk.Version == nil {
			break
		}

		return e.complexity.ArticleBlockMoveOk.Version(childComplexity), true

	case "ArticleBlockMutation.create":
		if e.complexity.ArticleBlockMutation.Create == nil {
			break
		}

		args, err := ec.field_ArticleBlockMutation_create_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleBlockMutation.Create(childComplexity, args["input"].(model.ArticleBlockCreateInput)), true

	case "ArticleBlockMutation.move":
		if e.complexity.ArticleBlockMutation.Move == nil {
			break
		}

		args, err := ec.field_ArticleBlockMutation_move_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleBlockMutation.Move(childComplexity, args["input"].(model.ArticleBlockMoveInput)), true

	case "ArticleBlockMutation.update":
		if e.complexity.ArticleBlockMutation.Update == nil {
			break
		}

		args, err := ec.field_ArticleBlockMutation_update_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleBlockMutation.Update(childComplexity, args["input"].(model.ArticleBlockUpdateInput)), true

	case "ArticleBlockNotFoundProblem.message":
		if e.complexity.ArticleBlockNotFoundProblem.Message == nil {
			break
		}

		return e.complexity.ArticleBlockNotFoundProblem.Message(childComplexity), true

	case "ArticleBlockQuery.find":
		if e.complexity.ArticleBlockQuery.Find == nil {
			break
		}

		args, err := ec.field_ArticleBlockQuery_find_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleBlockQuery.Find(childComplexity, args["filter"].(*model.ArticleBlockFindFilterInput), args["sort"].(model.ArticleBlockFindSortEnum), args["pageSize"].(uint), args["pageNumber"].(uint)), true

	case "ArticleBlockTypeMismatchProblem.message":
		if e.complexity.ArticleBlockTypeMismatchProblem.Message == nil {
			break
		}

		return e.complexity.ArticleBlockTypeMismatchProblem.Message(childComplexity), true

	case "ArticleBlockUpdateOk.articleBlock":
		if e.complexity.ArticleBlockUpdateOk.ArticleBlock == nil {
			break
		}

		return e.complexity.ArticleBlockUpdateOk.ArticleBlock(childComplexity), true

	case "ArticleContent.blocks":
		if e.complexity.ArticleContent.Blocks == nil {
			break
		}

		return e.complexity.ArticleContent.Blocks(childComplexity), true

	case "ArticleCreateOk.article":
		if e.complexity.ArticleCreateOk.Article == nil {
			break
		}

		return e.complexity.ArticleCreateOk.Article(childComplexity), true

	case "ArticleFindList.items":
		if e.complexity.ArticleFindList.Items == nil {
			break
		}

		return e.complexity.ArticleFindList.Items(childComplexity), true

	case "ArticleFindList.totalCount":
		if e.complexity.ArticleFindList.TotalCount == nil {
			break
		}

		args, err := ec.field_ArticleFindList_totalCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleFindList.TotalCount(childComplexity, args["estimate"].(uint)), true

	case "ArticleMutation.create":
		if e.complexity.ArticleMutation.Create == nil {
			break
		}

		args, err := ec.field_ArticleMutation_create_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleMutation.Create(childComplexity, args["input"].(model.ArticleCreateInput)), true

	case "ArticleMutation.update":
		if e.complexity.ArticleMutation.Update == nil {
			break
		}

		args, err := ec.field_ArticleMutation_update_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleMutation.Update(childComplexity, args["input"].(model.ArticleUpdateInput)), true

	case "ArticleNotFoundProblem.message":
		if e.complexity.ArticleNotFoundProblem.Message == nil {
			break
		}

		return e.complexity.ArticleNotFoundProblem.Message(childComplexity), true

	case "ArticleQuery.find":
		if e.complexity.ArticleQuery.Find == nil {
			break
		}

		args, err := ec.field_ArticleQuery_find_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleQuery.Find(childComplexity, args["filter"].(*model.ArticleFindFilterInput), args["sort"].(model.ArticleFindSortEnum), args["pageSize"].(uint), args["pageNumber"].(uint)), true

	case "ArticleTag.articleID":
		if e.complexity.ArticleTag.ArticleID == nil {
			break
		}

		return e.complexity.ArticleTag.ArticleID(childComplexity), true

	case "ArticleTag.createdAt":
		if e.complexity.ArticleTag.CreatedAt == nil {
			break
		}

		return e.complexity.ArticleTag.CreatedAt(childComplexity), true

	case "ArticleTag.id":
		if e.complexity.ArticleTag.ID == nil {
			break
		}

		return e.complexity.ArticleTag.ID(childComplexity), true

	case "ArticleTag.modifiedAt":
		if e.complexity.ArticleTag.ModifiedAt == nil {
			break
		}

		return e.complexity.ArticleTag.ModifiedAt(childComplexity), true

	case "ArticleTag.sortRank":
		if e.complexity.ArticleTag.SortRank == nil {
			break
		}

		return e.complexity.ArticleTag.SortRank(childComplexity), true

	case "ArticleTag.tag":
		if e.complexity.ArticleTag.Tag == nil {
			break
		}

		return e.complexity.ArticleTag.Tag(childComplexity), true

	case "ArticleTag.tagId":
		if e.complexity.ArticleTag.TagID == nil {
			break
		}

		return e.complexity.ArticleTag.TagID(childComplexity), true

	case "ArticleTag.version":
		if e.complexity.ArticleTag.Version == nil {
			break
		}

		return e.complexity.ArticleTag.Version(childComplexity), true

	case "ArticleTagAlreadyExistsProblem.message":
		if e.complexity.ArticleTagAlreadyExistsProblem.Message == nil {
			break
		}

		return e.complexity.ArticleTagAlreadyExistsProblem.Message(childComplexity), true

	case "ArticleTagCreateOk.articleTag":
		if e.complexity.ArticleTagCreateOk.ArticleTag == nil {
			break
		}

		return e.complexity.ArticleTagCreateOk.ArticleTag(childComplexity), true

	case "ArticleTagList.items":
		if e.complexity.ArticleTagList.Items == nil {
			break
		}

		return e.complexity.ArticleTagList.Items(childComplexity), true

	case "ArticleTagMoveOk.sortRank":
		if e.complexity.ArticleTagMoveOk.SortRank == nil {
			break
		}

		return e.complexity.ArticleTagMoveOk.SortRank(childComplexity), true

	case "ArticleTagMoveOk.version":
		if e.complexity.ArticleTagMoveOk.Version == nil {
			break
		}

		return e.complexity.ArticleTagMoveOk.Version(childComplexity), true

	case "ArticleTagMutation.create":
		if e.complexity.ArticleTagMutation.Create == nil {
			break
		}

		args, err := ec.field_ArticleTagMutation_create_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleTagMutation.Create(childComplexity, args["input"].(model.ArticleTagCreateInput)), true

	case "ArticleTagMutation.move":
		if e.complexity.ArticleTagMutation.Move == nil {
			break
		}

		args, err := ec.field_ArticleTagMutation_move_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ArticleTagMutation.Move(childComplexity, args["input"].(model.ArticleTagMoveInput)), true

	case "ArticleTagNotFoundProblem.message":
		if e.complexity.ArticleTagNotFoundProblem.Message == nil {
			break
		}

		return e.complexity.ArticleTagNotFoundProblem.Message(childComplexity), true

	case "ArticleUpdateOk.article":
		if e.complexity.ArticleUpdateOk.Article == nil {
			break
		}

		return e.complexity.ArticleUpdateOk.Article(childComplexity), true

	case "Image.assets":
		if e.complexity.Image.Assets == nil {
			break
		}

		return e.complexity.Image.Assets(childComplexity), true

	case "Image.createdAt":
		if e.complexity.Image.CreatedAt == nil {
			break
		}

		return e.complexity.Image.CreatedAt(childComplexity), true

	case "Image.deletedAt":
		if e.complexity.Image.DeletedAt == nil {
			break
		}

		return e.complexity.Image.DeletedAt(childComplexity), true

	case "Image.download":
		if e.complexity.Image.Download == nil {
			break
		}

		return e.complexity.Image.Download(childComplexity), true

	case "Image.height":
		if e.complexity.Image.Height == nil {
			break
		}

		return e.complexity.Image.Height(childComplexity), true

	case "Image.id":
		if e.complexity.Image.ID == nil {
			break
		}

		return e.complexity.Image.ID(childComplexity), true

	case "Image.modifiedAt":
		if e.complexity.Image.ModifiedAt == nil {
			break
		}

		return e.complexity.Image.ModifiedAt(childComplexity), true

	case "Image.type":
		if e.complexity.Image.Type == nil {
			break
		}

		return e.complexity.Image.Type(childComplexity), true

	case "Image.version":
		if e.complexity.Image.Version == nil {
			break
		}

		return e.complexity.Image.Version(childComplexity), true

	case "Image.width":
		if e.complexity.Image.Width == nil {
			break
		}

		return e.complexity.Image.Width(childComplexity), true

	case "ImageAsset.format":
		if e.complexity.ImageAsset.Format == nil {
			break
		}

		return e.complexity.ImageAsset.Format(childComplexity), true

	case "ImageAsset.url":
		if e.complexity.ImageAsset.URL == nil {
			break
		}

		return e.complexity.ImageAsset.URL(childComplexity), true

	case "ImageAsset.width":
		if e.complexity.ImageAsset.Width == nil {
			break
		}

		return e.complexity.ImageAsset.Width(childComplexity), true

	case "ImageDownload.url":
		if e.complexity.ImageDownload.URL == nil {
			break
		}

		return e.complexity.ImageDownload.URL(childComplexity), true

	case "ImageFindList.items":
		if e.complexity.ImageFindList.Items == nil {
			break
		}

		return e.complexity.ImageFindList.Items(childComplexity), true

	case "ImageFindList.totalCount":
		if e.complexity.ImageFindList.TotalCount == nil {
			break
		}

		args, err := ec.field_ImageFindList_totalCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ImageFindList.TotalCount(childComplexity, args["estimate"].(uint)), true

	case "ImageMutation.upload":
		if e.complexity.ImageMutation.Upload == nil {
			break
		}

		args, err := ec.field_ImageMutation_upload_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ImageMutation.Upload(childComplexity, args["input"].(model.ImageUploadInput)), true

	case "ImageNotFoundProblem.message":
		if e.complexity.ImageNotFoundProblem.Message == nil {
			break
		}

		return e.complexity.ImageNotFoundProblem.Message(childComplexity), true

	case "ImageNotRecognizedProblem.message":
		if e.complexity.ImageNotRecognizedProblem.Message == nil {
			break
		}

		return e.complexity.ImageNotRecognizedProblem.Message(childComplexity), true

	case "ImageNotSupportedTypeProblem.message":
		if e.complexity.ImageNotSupportedTypeProblem.Message == nil {
			break
		}

		return e.complexity.ImageNotSupportedTypeProblem.Message(childComplexity), true

	case "ImageQuery.find":
		if e.complexity.ImageQuery.Find == nil {
			break
		}

		args, err := ec.field_ImageQuery_find_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ImageQuery.Find(childComplexity, args["filter"].(*model.ImageFindFilterInput), args["sort"].(model.ImageFindSortEnum), args["pageSize"].(uint), args["pageNumber"].(uint)), true

	case "ImageUploadOk.image":
		if e.complexity.ImageUploadOk.Image == nil {
			break
		}

		return e.complexity.ImageUploadOk.Image(childComplexity), true

	case "InternalErrorProblem.message":
		if e.complexity.InternalErrorProblem.Message == nil {
			break
		}

		return e.complexity.InternalErrorProblem.Message(childComplexity), true

	case "InvalidSortRankProblem.message":
		if e.complexity.InvalidSortRankProblem.Message == nil {
			break
		}

		return e.complexity.InvalidSortRankProblem.Message(childComplexity), true

	case "Mutation.article":
		if e.complexity.Mutation.Article == nil {
			break
		}

		return e.complexity.Mutation.Article(childComplexity), true

	case "Mutation.articleBlock":
		if e.complexity.Mutation.ArticleBlock == nil {
			break
		}

		return e.complexity.Mutation.ArticleBlock(childComplexity), true

	case "Mutation.articleTag":
		if e.complexity.Mutation.ArticleTag == nil {
			break
		}

		return e.complexity.Mutation.ArticleTag(childComplexity), true

	case "Mutation.image":
		if e.complexity.Mutation.Image == nil {
			break
		}

		return e.complexity.Mutation.Image(childComplexity), true

	case "Mutation.project":
		if e.complexity.Mutation.Project == nil {
			break
		}

		return e.complexity.Mutation.Project(childComplexity), true

	case "Mutation.tag":
		if e.complexity.Mutation.Tag == nil {
			break
		}

		return e.complexity.Mutation.Tag(childComplexity), true

	case "Project.createdAt":
		if e.complexity.Project.CreatedAt == nil {
			break
		}

		return e.complexity.Project.CreatedAt(childComplexity), true

	case "Project.deletedAt":
		if e.complexity.Project.DeletedAt == nil {
			break
		}

		return e.complexity.Project.DeletedAt(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.modifiedAt":
		if e.complexity.Project.ModifiedAt == nil {
			break
		}

		return e.complexity.Project.ModifiedAt(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.version":
		if e.complexity.Project.Version == nil {
			break
		}

		return e.complexity.Project.Version(childComplexity), true

	case "ProjectAlreadyExistsProblem.message":
		if e.complexity.ProjectAlreadyExistsProblem.Message == nil {
			break
		}

		return e.complexity.ProjectAlreadyExistsProblem.Message(childComplexity), true

	case "ProjectCreateOk.project":
		if e.complexity.ProjectCreateOk.Project == nil {
			break
		}

		return e.complexity.ProjectCreateOk.Project(childComplexity), true

	case "ProjectFindList.items":
		if e.complexity.ProjectFindList.Items == nil {
			break
		}

		return e.complexity.ProjectFindList.Items(childComplexity), true

	case "ProjectFindList.totalCount":
		if e.complexity.ProjectFindList.TotalCount == nil {
			break
		}

		return e.complexity.ProjectFindList.TotalCount(childComplexity), true

	case "ProjectMutation.create":
		if e.complexity.ProjectMutation.Create == nil {
			break
		}

		args, err := ec.field_ProjectMutation_create_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectMutation.Create(childComplexity, args["input"].(model.ProjectCreateInput)), true

	case "ProjectMutation.update":
		if e.complexity.ProjectMutation.Update == nil {
			break
		}

		args, err := ec.field_ProjectMutation_update_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectMutation.Update(childComplexity, args["input"].(model.ProjectUpdateInput)), true

	case "ProjectNotFoundProblem.message":
		if e.complexity.ProjectNotFoundProblem.Message == nil {
			break
		}

		return e.complexity.ProjectNotFoundProblem.Message(childComplexity), true

	case "ProjectQuery.find":
		if e.complexity.ProjectQuery.Find == nil {
			break
		}

		args, err := ec.field_ProjectQuery_find_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectQuery.Find(childComplexity, args["filter"].(*model.ProjectFindFilterInput), args["sort"].(model.ProjectFindSortEnum), args["pageSize"].(uint), args["pageNumber"].(uint)), true

	case "ProjectUpdateOk.project":
		if e.complexity.ProjectUpdateOk.Project == nil {
			break
		}

		return e.complexity.ProjectUpdateOk.Project(childComplexity), true

	case "Query.article":
		if e.complexity.Query.Article == nil {
			break
		}

		return e.complexity.Query.Article(childComplexity), true

	case "Query.articleBlock":
		if e.complexity.Query.ArticleBlock == nil {
			break
		}

		return e.complexity.Query.ArticleBlock(childComplexity), true

	case "Query.image":
		if e.complexity.Query.Image == nil {
			break
		}

		return e.complexity.Query.Image(childComplexity), true

	case "Query.project":
		if e.complexity.Query.Project == nil {
			break
		}

		return e.complexity.Query.Project(childComplexity), true

	case "Query.tag":
		if e.complexity.Query.Tag == nil {
			break
		}

		return e.complexity.Query.Tag(childComplexity), true

	case "Subscription.articleBlockCreated":
		if e.complexity.Subscription.ArticleBlockCreated == nil {
			break
		}

		args, err := ec.field_Subscription_articleBlockCreated_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ArticleBlockCreated(childComplexity, args["articleId"].(uuid.UUID)), true

	case "Tag.createdAt":
		if e.complexity.Tag.CreatedAt == nil {
			break
		}

		return e.complexity.Tag.CreatedAt(childComplexity), true

	case "Tag.deletedAt":
		if e.complexity.Tag.DeletedAt == nil {
			break
		}

		return e.complexity.Tag.DeletedAt(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.modifiedAt":
		if e.complexity.Tag.ModifiedAt == nil {
			break
		}

		return e.complexity.Tag.ModifiedAt(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "Tag.version":
		if e.complexity.Tag.Version == nil {
			break
		}

		return e.complexity.Tag.Version(childComplexity), true

	case "TagAlreadyExistsProblem.message":
		if e.complexity.TagAlreadyExistsProblem.Message == nil {
			break
		}

		return e.complexity.TagAlreadyExistsProblem.Message(childComplexity), true

	case "TagCreateOk.tag":
		if e.complexity.TagCreateOk.Tag == nil {
			break
		}

		return e.complexity.TagCreateOk.Tag(childComplexity), true

	case "TagFindList.items":
		if e.complexity.TagFindList.Items == nil {
			break
		}

		return e.complexity.TagFindList.Items(childComplexity), true

	case "TagFindList.totalCount":
		if e.complexity.TagFindList.TotalCount == nil {
			break
		}

		args, err := ec.field_TagFindList_totalCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagFindList.TotalCount(childComplexity, args["estimate"].(uint)), true

	case "TagMutation.create":
		if e.complexity.TagMutation.Create == nil {
			break
		}

		args, err := ec.field_TagMutation_create_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagMutation.Create(childComplexity, args["input"].(model.TagCreateInput)), true

	case "TagMutation.update":
		if e.complexity.TagMutation.Update == nil {
			break
		}

		args, err := ec.field_TagMutation_update_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagMutation.Update(childComplexity, args["input"].(model.TagUpdateInput)), true

	case "TagNotFoundProblem.message":
		if e.complexity.TagNotFoundProblem.Message == nil {
			break
		}

		return e.complexity.TagNotFoundProblem.Message(childComplexity), true

	case "TagQuery.find":
		if e.complexity.TagQuery.Find == nil {
			break
		}

		args, err := ec.field_TagQuery_find_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TagQuery.Find(childComplexity, args["filter"].(*model.TagFindFilterInput), args["sort"].(model.TagFindSortEnum), args["pageSize"].(uint), args["pageNumber"].(uint)), true

	case "TagUpdateOk.tag":
		if e.complexity.TagUpdateOk.Tag == nil {
			break
		}

		return e.complexity.TagUpdateOk.Tag(childComplexity), true

	case "TotalCount.value":
		if e.complexity.TotalCount.Value == nil {
			break
		}

		return e.complexity.TotalCount.Value(childComplexity), true

	case "VersionMismatchProblem.message":
		if e.complexity.VersionMismatchProblem.Message == nil {
			break
		}

		return e.complexity.VersionMismatchProblem.Message(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputArticleBlockCreateInput,
		ec.unmarshalInputArticleBlockDataInput,
		ec.unmarshalInputArticleBlockFindFilterInput,
		ec.unmarshalInputArticleBlockHtmlDataInput,
		ec.unmarshalInputArticleBlockImageDataInput,
		ec.unmarshalInputArticleBlockMoveInput,
		ec.unmarshalInputArticleBlockUpdateInput,
		ec.unmarshalInputArticleCreateInput,
		ec.unmarshalInputArticleFindFilterInput,
		ec.unmarshalInputArticleTagCreateInput,
		ec.unmarshalInputArticleTagMoveInput,
		ec.unmarshalInputArticleUpdateInput,
		ec.unmarshalInputImageFindFilterInput,
		ec.unmarshalInputImageUploadInput,
		ec.unmarshalInputProjectCreateInput,
		ec.unmarshalInputProjectFindFilterInput,
		ec.unmarshalInputProjectUpdateInput,
		ec.unmarshalInputSortRankInput,
		ec.unmarshalInputTagCreateInput,
		ec.unmarshalInputTagFindFilterInput,
		ec.unmarshalInputTagUpdateInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../api/_directives.graphql", Input: `directive @goModel(
    model: String
    models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @inputUnion on INPUT_FIELD_DEFINITION

directive @sortRankInput on INPUT_FIELD_DEFINITION`, BuiltIn: false},
	{Name: "../../../api/_scalars.graphql", Input: `scalar Html
scalar PageNumber
scalar PageSize
scalar Rfc3339Date
scalar UInt
scalar Upload
scalar Url
scalar Uuid`, BuiltIn: false},
	{Name: "../../../api/article.graphql", Input: `type Article implements VersionInterface {
    content: ArticleContentResolvingResult! @goField(forceResolver: true)
    coverImage: ImageResolvingResult! @goField(forceResolver: true)
    coverImageId: Uuid
    createdAt: Rfc3339Date!
    deletedAt: Rfc3339Date
    id: Uuid!
    modifiedAt: Rfc3339Date!
    project: ProjectResolvingResult! @goField(forceResolver: true)
    projectId: Uuid!
    tags: ArticleTagsResolvingResult! @goField(forceResolver: true)
    title: String!
    version: UInt!
}

type ArticleContent {
    blocks: [ArticleBlockInterface!]!
}

type ArticleNotFoundProblem implements ProblemInterface {
    message: String!
}

union ArticleContentResolvingResult =
    | ArticleContent
    | InternalErrorProblem

union ArticleTagsResolvingResult =
    | ArticleTagList
    | InternalErrorProblem`, BuiltIn: false},
	{Name: "../../../api/articleblock.graphql", Input: `interface ArticleBlockInterface {
    createdAt: Rfc3339Date!
    deletedAt: Rfc3339Date
    id: Uuid!
    modifiedAt: Rfc3339Date!
    sortRank: String!
}

type ArticleBlockNotFoundProblem implements ProblemInterface {
    message: String!
}

enum ArticleBlockTypeEnum {
    HTML
    IMAGE
}`, BuiltIn: false},
	{Name: "../../../api/articleblockhtml.graphql", Input: `type ArticleBlockHtml implements ArticleBlockInterface & VersionInterface {
    createdAt: Rfc3339Date!
    data: ArticleBlockHtmlData!
    deletedAt: Rfc3339Date
    id: Uuid!
    modifiedAt: Rfc3339Date!
    sortRank: String!
    version: UInt!
}

type ArticleBlockHtmlData {
    body: Html!
}

input ArticleBlockHtmlDataInput {
    body: Html!
}`, BuiltIn: false},
	{Name: "../../../api/articleblockimage.graphql", Input: `type ArticleBlockImage implements ArticleBlockInterface & VersionInterface {
    createdAt: Rfc3339Date!
    data: ArticleBlockImageData!
    deletedAt: Rfc3339Date
    id: Uuid!
    modifiedAt: Rfc3339Date!
    sortRank: String!
    version: UInt!
}

type ArticleBlockImageData {
    image: ImageResolvingResult! @goField(forceResolver: true)
    imageId: Uuid
    copyright: String
    description: Html
}

input ArticleBlockImageDataInput {
    imageId: Uuid
    copyright: String
    description: Html
}`, BuiltIn: false},
	{Name: "../../../api/articleblockmutation.graphql", Input: `type ArticleBlockMutation

extend type Mutation {
    articleBlock: ArticleBlockMutation!
}`, BuiltIn: false},
	{Name: "../../../api/articleblockmutation_create.graphql", Input: `extend type ArticleBlockMutation {
    create(
        input: ArticleBlockCreateInput!
    ): ArticleBlockCreateResult! @goField(forceResolver: true)
}

input ArticleBlockCreateInput {
    articleId: Uuid!
    blockType: ArticleBlockTypeEnum!
    sortRank: SortRankInput! @sortRankInput
}

type ArticleBlockCreateOk {
    articleBlock: ArticleBlockInterface!
}

union ArticleBlockCreateResult =
    | ArticleNotFoundProblem
    | InvalidSortRankProblem
    | InternalErrorProblem
    | ArticleBlockCreateOk
`, BuiltIn: false},
	{Name: "../../../api/articleblockmutation_move.graphql", Input: `extend type ArticleBlockMutation {
    move(input: ArticleBlockMoveInput!): ArticleBlockMoveResult! @goField(forceResolver: true)
}

input ArticleBlockMoveInput {
    id: Uuid!
    sortRank: SortRankInput! @sortRankInput
    version: UInt!
}

type ArticleBlockMoveOk {
    sortRank: String!
    version: UInt!
}

union ArticleBlockMoveResult =
    | ArticleBlockNotFoundProblem
    | InvalidSortRankProblem
    | VersionMismatchProblem
    | InternalErrorProblem
    | ArticleBlockMoveOk`, BuiltIn: false},
	{Name: "../../../api/articleblockmutation_update.graphql", Input: `extend type ArticleBlockMutation {
    update(input: ArticleBlockUpdateInput!): ArticleBlockUpdateResult! @goField(forceResolver: true)
}

input ArticleBlockUpdateInput {
    id: Uuid!
    data: ArticleBlockDataInput! @inputUnion
    version: UInt!
}

input ArticleBlockDataInput {
    html: ArticleBlockHtmlDataInput
    image: ArticleBlockImageDataInput
}

type ArticleBlockUpdateOk {
    articleBlock: ArticleBlockInterface!
}

type ArticleBlockTypeMismatchProblem implements ProblemInterface {
    message: String!
}

union ArticleBlockUpdateResult =
    | ArticleBlockNotFoundProblem
    | ArticleBlockTypeMismatchProblem
    | VersionMismatchProblem
    | InternalErrorProblem
    | ArticleBlockUpdateOk
`, BuiltIn: false},
	{Name: "../../../api/articleblockquery.graphql", Input: `type ArticleBlockQuery

extend type Query {
    articleBlock: ArticleBlockQuery!
}`, BuiltIn: false},
	{Name: "../../../api/articleblockquery_find.graphql", Input: `extend type ArticleBlockQuery {
    find(
        filter: ArticleBlockFindFilterInput
        sort: ArticleBlockFindSortEnum! = SORT_RANK_ASC
        pageSize: PageSize! = 10
        pageNumber: PageNumber! = 1
    ): ArticleBlockFindResult! @goField(forceResolver: true)
}

enum ArticleBlockFindSortEnum {
    CREATED_AT_ASC
    CREATED_AT_DESC
    SORT_RANK_ASC
    SORT_RANK_DESC
}

input ArticleBlockFindFilterInput {
    articleIdAnyOf: [Uuid!]
    idAnyOf: [Uuid!]
    typeAnyOf: [ArticleBlockTypeEnum!]
}

type ArticleBlockFindList {
    items: [ArticleBlockInterface!]!
    totalCount(estimate: UInt! = 10000): TotalCountResolvingResult! @goField(forceResolver: true)
}

union ArticleBlockFindResult =
    | ArticleBlockFindList
    | InternalErrorProblem`, BuiltIn: false},
	{Name: "../../../api/articleblocksubscription.graphql", Input: `extend type Subscription {
    articleBlockCreated(articleId: Uuid!): ArticleBlockInterface!
}`, BuiltIn: false},
	{Name: "../../../api/articlemutation.graphql", Input: `type ArticleMutation

extend type Mutation {
    article: ArticleMutation!
}`, BuiltIn: false},
	{Name: "../../../api/articlemutation_create.graphql", Input: `extend type ArticleMutation {
    create(input: ArticleCreateInput!): ArticleCreateResult! @goField(forceResolver: true)
}

input ArticleCreateInput {
    projectId: Uuid!
}

type ArticleCreateOk {
    article: Article!
}

union ArticleCreateResult =
    | ProjectNotFoundProblem
    | InternalErrorProblem
    | ArticleCreateOk`, BuiltIn: false},
	{Name: "../../../api/articlemutation_update.graphql", Input: `extend type ArticleMutation {
    update(
        input: ArticleUpdateInput!
    ): ArticleUpdateResult! @goField(forceResolver: true)
}

input ArticleUpdateInput {
    id: Uuid!
    coverImageId: Uuid
    title: String!
    version: UInt!
}

type ArticleUpdateOk {
    article: Article!
}

union ArticleUpdateResult =
    | ArticleNotFoundProblem
    | VersionMismatchProblem
    | InternalErrorProblem
    | ArticleUpdateOk`, BuiltIn: false},
	{Name: "../../../api/articlequery.graphql", Input: `type ArticleQuery

extend type Query {
    article: ArticleQuery!
}`, BuiltIn: false},
	{Name: "../../../api/articlequery_find.graphql", Input: `extend type ArticleQuery {
    find(
        filter: ArticleFindFilterInput
        sort: ArticleFindSortEnum! = CREATED_AT_ASC
        pageSize: PageSize! = 10
        pageNumber: PageNumber! = 1
    ): ArticleFindResult! @goField(forceResolver: true)
}

enum ArticleFindSortEnum {
    CREATED_AT_ASC
    CREATED_AT_DESC
}

input ArticleFindFilterInput {
    idAnyOf: [Uuid!]
}

type ArticleFindList {
    items: [Article!]!
    totalCount(estimate: UInt! = 10000): TotalCountResolvingResult! @goField(forceResolver: true)
}

union ArticleFindResult =
    | ArticleFindList
    | InternalErrorProblem`, BuiltIn: false},
	{Name: "../../../api/articletag.graphql", Input: `type ArticleTag implements VersionInterface {
    articleID: Uuid!
    createdAt: Rfc3339Date!
    id: Uuid!
    modifiedAt: Rfc3339Date!
    sortRank: String!
    tag: TagResolvingResult! @goField(forceResolver: true)
    tagId: Uuid!
    version: UInt!
}

type ArticleTagList {
    items: [ArticleTag!]!
}

type ArticleTagNotFoundProblem implements ProblemInterface {
    message: String!
}`, BuiltIn: false},
	{Name: "../../../api/articletagmutation.graphql", Input: `type ArticleTagMutation

extend type Mutation {
    articleTag: ArticleTagMutation!
}`, BuiltIn: false},
	{Name: "../../../api/articletagmutation_create.graphql", Input: `extend type ArticleTagMutation {
    create(input: ArticleTagCreateInput!): ArticleTagCreateResult! @goField(forceResolver: true)
}

input ArticleTagCreateInput {
    articleId: Uuid!
    tagId: Uuid!
    sortRank: SortRankInput! @sortRankInput
}

type ArticleTagAlreadyExistsProblem implements ProblemInterface {
    message: String!
}

type ArticleTagCreateOk {
    articleTag: ArticleTag!
}

union ArticleTagCreateResult =
    | ArticleNotFoundProblem
    | TagNotFoundProblem
    | ArticleTagAlreadyExistsProblem
    | InvalidSortRankProblem
    | InternalErrorProblem
    | ArticleTagCreateOk`, BuiltIn: false},
	{Name: "../../../api/articletagmutation_move.graphql", Input: `extend type ArticleTagMutation {
    move(input: ArticleTagMoveInput!): ArticleTagMoveResult! @goField(forceResolver: true)
}

input ArticleTagMoveInput {
    id: Uuid!
    sortRank: SortRankInput! @sortRankInput
    version: UInt!
}

type ArticleTagMoveOk {
    sortRank: String!
    version: UInt!
}

union ArticleTagMoveResult =
    | ArticleTagNotFoundProblem
    | InvalidSortRankProblem
    | VersionMismatchProblem
    | InternalErrorProblem
    | ArticleTagMoveOk`, BuiltIn: false},
	{Name: "../../../api/image.graphql", Input: `type Image implements VersionInterface {
    assets: [ImageAsset!]! @goField(forceResolver: true)
    createdAt: Rfc3339Date!
    deletedAt: Rfc3339Date
    type: String!
    height: UInt!
    id: Uuid!
    modifiedAt: Rfc3339Date!
    download: ImageDownloadResolvingResult! @goField(forceResolver: true)
    version: UInt!
    width: UInt!
}

type ImageAsset {
    format: ImageAssetFormat!
    width: ImageAssetWidth!
    url: Url!
}

type ImageDownload {
    url: Url!
}

type ImageNotFoundProblem implements ProblemInterface {
    message: String!
}

union ImageResolvingResult =
    | Image
    | ImageNotFoundProblem
    | InternalErrorProblem

union ImageDownloadResolvingResult =
    | ImageDownload
    | InternalErrorProblem

enum ImageAssetFormat {
    AVIF
    JPEG
    PNG
    WEBP
}

enum ImageAssetWidth {
    W320
    W768
    W1024
    W1280
    W1366
    W1600
    W1920
    W2560
}`, BuiltIn: false},
	{Name: "../../../api/imagemutation.graphql", Input: `type ImageMutation

extend type Mutation {
    image: ImageMutation!
}`, BuiltIn: false},
	{Name: "../../../api/imagemutation_upload.graphql", Input: `extend type ImageMutation {
    upload(input: ImageUploadInput!): ImageUploadResult! @goField(forceResolver: true)
}

input ImageUploadInput {
    file: Upload
}

type ImageNotSupportedTypeProblem implements ProblemInterface {
    message: String!
}

type ImageNotRecognizedProblem implements ProblemInterface {
    message: String!
}

type ImageUploadOk {
    image: Image!
}

union ImageUploadResult =
    | ImageNotSupportedTypeProblem
    | ImageNotRecognizedProblem
    | InternalErrorProblem
    | ImageUploadOk
`, BuiltIn: false},
	{Name: "../../../api/imagequery.graphql", Input: `type ImageQuery

extend type Query {
    image: ImageQuery!
}`, BuiltIn: false},
	{Name: "../../../api/imagequery_find.graphql", Input: `extend type ImageQuery {
    find(
        filter: ImageFindFilterInput
        sort: ImageFindSortEnum! = CREATED_AT_ASC
        pageSize: PageSize! = 10
        pageNumber: PageNumber! = 1
    ): ImageFindResult! @goField(forceResolver: true)
}

enum ImageFindSortEnum {
    CREATED_AT_ASC
    CREATED_AT_DESC
}

input ImageFindFilterInput {
    idAnyOf: [Uuid!]
}

type ImageFindList {
    items: [Image!]!
    totalCount(estimate: UInt! = 10000): TotalCountResolvingResult! @goField(forceResolver: true)
}

union ImageFindResult =
    | ImageFindList
    | InternalErrorProblem`, BuiltIn: false},
	{Name: "../../../api/mutation.graphql", Input: `type Mutation`, BuiltIn: false},
	{Name: "../../../api/problem.graphql", Input: `interface ProblemInterface {
    message: String!
}

type InternalErrorProblem implements ProblemInterface {
    message: String!
}`, BuiltIn: false},
	{Name: "../../../api/project.graphql", Input: `type Project implements VersionInterface {
    createdAt: Rfc3339Date!
    deletedAt: Rfc3339Date
    id: Uuid!
    modifiedAt: Rfc3339Date!
    name: String!
    version: UInt!
}

type ProjectNotFoundProblem implements ProblemInterface {
    message: String!
}

union ProjectResolvingResult =
    | Project
    | ProjectNotFoundProblem
    | InternalErrorProblem
`, BuiltIn: false},
	{Name: "../../../api/projectmutation.graphql", Input: `type ProjectMutation

extend type Mutation {
    project: ProjectMutation!
}`, BuiltIn: false},
	{Name: "../../../api/projectmutation_create.graphql", Input: `extend type ProjectMutation {
    create(input: ProjectCreateInput!): ProjectCreateResult! @goField(forceResolver: true)
}

input ProjectCreateInput {
    name: String!
}

type ProjectAlreadyExistsProblem implements ProblemInterface {
    message: String!
}

type ProjectCreateOk {
    project: Project!
}

union ProjectCreateResult =
    | ProjectAlreadyExistsProblem
    | InternalErrorProblem
    | ProjectCreateOk`, BuiltIn: false},
	{Name: "../../../api/projectmutation_update.graphql", Input: `extend type ProjectMutation {
    update(input: ProjectUpdateInput!): ProjectUpdateResult! @goField(forceResolver: true)
}

input ProjectUpdateInput {
    id: Uuid!
    name: String!
    version: UInt!
}

type ProjectUpdateOk {
    project: Project!
}

union ProjectUpdateResult =
    | ProjectNotFoundProblem
    | VersionMismatchProblem
    | InternalErrorProblem
    | ProjectUpdateOk
`, BuiltIn: false},
	{Name: "../../../api/projectquery.graphql", Input: `type ProjectQuery

extend type Query {
    project: ProjectQuery!
}`, BuiltIn: false},
	{Name: "../../../api/projectquery_find.graphql", Input: `extend type ProjectQuery {
    find(
        filter: ProjectFindFilterInput
        sort: ProjectFindSortEnum! = NAME_ASC
        pageSize: PageSize! = 10
        pageNumber: PageNumber! = 1
    ): ProjectFindResult! @goField(forceResolver: true)
}

enum ProjectFindSortEnum {
    NAME_ASC
    NAME_DESC
    CREATED_AT_ASC
    CREATED_AT_DESC
}

input ProjectFindFilterInput {
    idAnyOf: [Uuid!]
}

type ProjectFindList {
    items: [Project!]!
    totalCount: TotalCountResolvingResult! @goField(forceResolver: true)
}

union ProjectFindResult =
    | ProjectFindList
    | InternalErrorProblem`, BuiltIn: false},
	{Name: "../../../api/query.graphql", Input: `type Query`, BuiltIn: false},
	{Name: "../../../api/sortrank.graphql", Input: `input SortRankInput {
    prev: String! = "0"
    next: String! = "z"
}

type InvalidSortRankProblem implements ProblemInterface {
    message: String!
}
`, BuiltIn: false},
	{Name: "../../../api/subscription.graphql", Input: `type Subscription`, BuiltIn: false},
	{Name: "../../../api/tag.graphql", Input: `type Tag implements VersionInterface {
    createdAt: Rfc3339Date!
    deletedAt: Rfc3339Date
    id: Uuid!
    modifiedAt: Rfc3339Date!
    name: String!
    version: UInt!
}

type TagNotFoundProblem implements ProblemInterface {
    message: String!
}

union TagResolvingResult =
    | Tag
    | TagNotFoundProblem
    | InternalErrorProblem
`, BuiltIn: false},
	{Name: "../../../api/tagmutation.graphql", Input: `type TagMutation

extend type Mutation {
    tag: TagMutation!
}`, BuiltIn: false},
	{Name: "../../../api/tagmutation_create.graphql", Input: `extend type TagMutation {
    create(input: TagCreateInput!): TagCreateResult! @goField(forceResolver: true)
}

input TagCreateInput {
    name: String!
}

type TagAlreadyExistsProblem implements ProblemInterface {
    message: String!
}

type TagCreateOk {
    tag: Tag!
}

union TagCreateResult =
    | TagAlreadyExistsProblem
    | InternalErrorProblem
    | TagCreateOk`, BuiltIn: false},
	{Name: "../../../api/tagmutation_update.graphql", Input: `extend type TagMutation {
    update(input: TagUpdateInput!): TagUpdateResult! @goField(forceResolver: true)
}

input TagUpdateInput {
    id: Uuid!
    name: String!
    version: UInt!
}

type TagUpdateOk {
    tag: Tag!
}

union TagUpdateResult =
    | TagNotFoundProblem
    | VersionMismatchProblem
    | InternalErrorProblem
    | TagUpdateOk
`, BuiltIn: false},
	{Name: "../../../api/tagquery.graphql", Input: `type TagQuery

extend type Query {
    tag: TagQuery!
}`, BuiltIn: false},
	{Name: "../../../api/tagquery_find.graphql", Input: `extend type TagQuery {
    find(
        filter: TagFindFilterInput
        sort: TagFindSortEnum! = NAME_ASC
        pageSize: PageSize! = 10
        pageNumber: PageNumber! = 1
    ): TagFindResult! @goField(forceResolver: true)
}

enum TagFindSortEnum {
    NAME_ASC
    NAME_DESC
    CREATED_AT_ASC
    CREATED_AT_DESC
}

input TagFindFilterInput {
    idAnyOf: [Uuid!]
}

type TagFindList {
    items: [Tag!]!
    totalCount(estimate: UInt! = 10000): TotalCountResolvingResult! @goField(forceResolver: true)
}

union TagFindResult =
    | TagFindList
    | InternalErrorProblem`, BuiltIn: false},
	{Name: "../../../api/totalcount.graphql", Input: `type TotalCount {
    value: UInt!
}

union TotalCountResolvingResult =
    | TotalCount
    | InternalErrorProblem`, BuiltIn: false},
	{Name: "../../../api/version.graphql", Input: `interface VersionInterface {
    version: UInt!
}

type VersionMismatchProblem implements ProblemInterface {
    message: String!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_ArticleBlockFindList_totalCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint
	if tmp, ok := rawArgs["estimate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("estimate"))
		arg0, err = ec.unmarshalNUInt2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["estimate"] = arg0
	return args, nil
}

func (ec *executionContext) field_ArticleBlockMutation_create_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ArticleBlockCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNArticleBlockCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ArticleBlockMutation_move_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ArticleBlockMoveInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNArticleBlockMoveInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockMoveInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ArticleBlockMutation_update_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ArticleBlockUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNArticleBlockUpdateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ArticleBlockQuery_find_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ArticleBlockFindFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOArticleBlockFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockFindFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 model.ArticleBlockFindSortEnum
	if tmp, ok := rawArgs["sort"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
		arg1, err = ec.unmarshalNArticleBlockFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockFindSortEnum(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg1
	var arg2 uint
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNPageSize2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	var arg3 uint
	if tmp, ok := rawArgs["pageNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageNumber"))
		arg3, err = ec.unmarshalNPageNumber2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageNumber"] = arg3
	return args, nil
}

func (ec *executionContext) field_ArticleFindList_totalCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint
	if tmp, ok := rawArgs["estimate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("estimate"))
		arg0, err = ec.unmarshalNUInt2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["estimate"] = arg0
	return args, nil
}

func (ec *executionContext) field_ArticleMutation_create_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ArticleCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNArticleCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ArticleMutation_update_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ArticleUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNArticleUpdateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ArticleQuery_find_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ArticleFindFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOArticleFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleFindFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 model.ArticleFindSortEnum
	if tmp, ok := rawArgs["sort"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
		arg1, err = ec.unmarshalNArticleFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleFindSortEnum(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg1
	var arg2 uint
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNPageSize2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	var arg3 uint
	if tmp, ok := rawArgs["pageNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageNumber"))
		arg3, err = ec.unmarshalNPageNumber2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageNumber"] = arg3
	return args, nil
}

func (ec *executionContext) field_ArticleTagMutation_create_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ArticleTagCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNArticleTagCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ArticleTagMutation_move_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ArticleTagMoveInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNArticleTagMoveInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagMoveInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ImageFindList_totalCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint
	if tmp, ok := rawArgs["estimate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("estimate"))
		arg0, err = ec.unmarshalNUInt2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["estimate"] = arg0
	return args, nil
}

func (ec *executionContext) field_ImageMutation_upload_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ImageUploadInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNImageUploadInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageUploadInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ImageQuery_find_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ImageFindFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOImageFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageFindFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 model.ImageFindSortEnum
	if tmp, ok := rawArgs["sort"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
		arg1, err = ec.unmarshalNImageFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageFindSortEnum(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg1
	var arg2 uint
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNPageSize2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	var arg3 uint
	if tmp, ok := rawArgs["pageNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageNumber"))
		arg3, err = ec.unmarshalNPageNumber2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageNumber"] = arg3
	return args, nil
}

func (ec *executionContext) field_ProjectMutation_create_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ProjectCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNProjectCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ProjectMutation_update_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ProjectUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNProjectUpdateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ProjectQuery_find_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ProjectFindFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOProjectFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectFindFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 model.ProjectFindSortEnum
	if tmp, ok := rawArgs["sort"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
		arg1, err = ec.unmarshalNProjectFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectFindSortEnum(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg1
	var arg2 uint
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNPageSize2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	var arg3 uint
	if tmp, ok := rawArgs["pageNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageNumber"))
		arg3, err = ec.unmarshalNPageNumber2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageNumber"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_articleBlockCreated_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uuid.UUID
	if tmp, ok := rawArgs["articleId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("articleId"))
		arg0, err = ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["articleId"] = arg0
	return args, nil
}

func (ec *executionContext) field_TagFindList_totalCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint
	if tmp, ok := rawArgs["estimate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("estimate"))
		arg0, err = ec.unmarshalNUInt2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["estimate"] = arg0
	return args, nil
}

func (ec *executionContext) field_TagMutation_create_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TagCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNTagCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_TagMutation_update_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TagUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNTagUpdateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_TagQuery_find_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.TagFindFilterInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTagFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagFindFilterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 model.TagFindSortEnum
	if tmp, ok := rawArgs["sort"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
		arg1, err = ec.unmarshalNTagFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagFindSortEnum(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg1
	var arg2 uint
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNPageSize2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	var arg3 uint
	if tmp, ok := rawArgs["pageNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageNumber"))
		arg3, err = ec.unmarshalNPageNumber2uint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageNumber"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Article_content(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Article().Content(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleContentResolvingResult)
	fc.Result = res
	return ec.marshalNArticleContentResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleContentResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleContentResolvingResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_coverImage(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_coverImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Article().CoverImage(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ImageResolvingResult)
	fc.Result = res
	return ec.marshalNImageResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_coverImage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageResolvingResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_coverImageId(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_coverImageId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoverImageID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUuid2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_coverImageId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalORfc3339Date2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_id(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_modifiedAt(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_modifiedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_modifiedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_project(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Article().Project(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProjectResolvingResult)
	fc.Result = res
	return ec.marshalNProjectResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectResolvingResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_projectId(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_projectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_projectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_tags(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Article().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleTagsResolvingResult)
	fc.Result = res
	return ec.marshalNArticleTagsResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagsResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleTagsResolvingResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_title(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Article_version(ctx context.Context, field graphql.CollectedField, obj *model.Article) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Article_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Article_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Article",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockCreateOk_articleBlock(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockCreateOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockCreateOk_articleBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArticleBlock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleBlockInterface)
	fc.Result = res
	return ec.marshalNArticleBlockInterface2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockCreateOk_articleBlock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockCreateOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockFindList_items(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockFindList_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ArticleBlockInterface)
	fc.Result = res
	return ec.marshalNArticleBlockInterface2ᚕgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockInterfaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockFindList_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockFindList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockFindList_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockFindList_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleBlockFindList().TotalCount(rctx, obj, fc.Args["estimate"].(uint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TotalCountResolvingResult)
	fc.Result = res
	return ec.marshalNTotalCountResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTotalCountResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockFindList_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockFindList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TotalCountResolvingResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleBlockFindList_totalCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockHtml_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockHTML) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockHtml_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockHtml_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockHtml",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockHtml_data(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockHTML) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockHtml_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ArticleBlockHTMLData)
	fc.Result = res
	return ec.marshalNArticleBlockHtmlData2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockHTMLData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockHtml_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockHtml",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "body":
				return ec.fieldContext_ArticleBlockHtmlData_body(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArticleBlockHtmlData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockHtml_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockHTML) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockHtml_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalORfc3339Date2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockHtml_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockHtml",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockHtml_id(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockHTML) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockHtml_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockHtml_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockHtml",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockHtml_modifiedAt(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockHTML) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockHtml_modifiedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockHtml_modifiedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockHtml",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockHtml_sortRank(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockHTML) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockHtml_sortRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockHtml_sortRank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockHtml",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockHtml_version(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockHTML) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockHtml_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockHtml_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockHtml",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockHtmlData_body(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockHTMLData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockHtmlData_body(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Body, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNHtml2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockHtmlData_body(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockHtmlData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Html does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImage_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImage_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImage_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImage_data(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ArticleBlockImageData)
	fc.Result = res
	return ec.marshalNArticleBlockImageData2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockImageData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "image":
				return ec.fieldContext_ArticleBlockImageData_image(ctx, field)
			case "imageId":
				return ec.fieldContext_ArticleBlockImageData_imageId(ctx, field)
			case "copyright":
				return ec.fieldContext_ArticleBlockImageData_copyright(ctx, field)
			case "description":
				return ec.fieldContext_ArticleBlockImageData_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArticleBlockImageData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImage_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImage_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalORfc3339Date2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImage_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImage_id(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImage_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImage_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImage_modifiedAt(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImage_modifiedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImage_modifiedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImage_sortRank(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImage_sortRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImage_sortRank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImage_version(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImage_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImage_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImageData_image(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImageData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImageData_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleBlockImageData().Image(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ImageResolvingResult)
	fc.Result = res
	return ec.marshalNImageResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImageData_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImageData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageResolvingResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImageData_imageId(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImageData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImageData_imageId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUuid2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImageData_imageId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImageData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImageData_copyright(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImageData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImageData_copyright(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Copyright, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImageData_copyright(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImageData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockImageData_description(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockImageData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockImageData_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOHtml2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockImageData_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockImageData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Html does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockMoveOk_sortRank(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockMoveOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockMoveOk_sortRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockMoveOk_sortRank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockMoveOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockMoveOk_version(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockMoveOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockMoveOk_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockMoveOk_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockMoveOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockMutation_create(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockMutation_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleBlockMutation().Create(rctx, obj, fc.Args["input"].(model.ArticleBlockCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleBlockCreateResult)
	fc.Result = res
	return ec.marshalNArticleBlockCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockCreateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockMutation_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleBlockCreateResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleBlockMutation_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockMutation_move(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockMutation_move(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleBlockMutation().Move(rctx, obj, fc.Args["input"].(model.ArticleBlockMoveInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleBlockMoveResult)
	fc.Result = res
	return ec.marshalNArticleBlockMoveResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockMoveResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockMutation_move(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleBlockMoveResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleBlockMutation_move_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockMutation_update(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockMutation_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleBlockMutation().Update(rctx, obj, fc.Args["input"].(model.ArticleBlockUpdateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleBlockUpdateResult)
	fc.Result = res
	return ec.marshalNArticleBlockUpdateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockMutation_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleBlockUpdateResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleBlockMutation_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockNotFoundProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockNotFoundProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockNotFoundProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockNotFoundProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockNotFoundProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockQuery_find(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockQuery_find(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleBlockQuery().Find(rctx, obj, fc.Args["filter"].(*model.ArticleBlockFindFilterInput), fc.Args["sort"].(model.ArticleBlockFindSortEnum), fc.Args["pageSize"].(uint), fc.Args["pageNumber"].(uint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleBlockFindResult)
	fc.Result = res
	return ec.marshalNArticleBlockFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockFindResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockQuery_find(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleBlockFindResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleBlockQuery_find_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockTypeMismatchProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockTypeMismatchProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockTypeMismatchProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockTypeMismatchProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockTypeMismatchProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleBlockUpdateOk_articleBlock(ctx context.Context, field graphql.CollectedField, obj *model.ArticleBlockUpdateOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleBlockUpdateOk_articleBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArticleBlock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleBlockInterface)
	fc.Result = res
	return ec.marshalNArticleBlockInterface2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleBlockUpdateOk_articleBlock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleBlockUpdateOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleContent_blocks(ctx context.Context, field graphql.CollectedField, obj *model.ArticleContent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleContent_blocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Blocks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ArticleBlockInterface)
	fc.Result = res
	return ec.marshalNArticleBlockInterface2ᚕgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockInterfaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleContent_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleContent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleCreateOk_article(ctx context.Context, field graphql.CollectedField, obj *model.ArticleCreateOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleCreateOk_article(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Article, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Article)
	fc.Result = res
	return ec.marshalNArticle2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleCreateOk_article(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleCreateOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "content":
				return ec.fieldContext_Article_content(ctx, field)
			case "coverImage":
				return ec.fieldContext_Article_coverImage(ctx, field)
			case "coverImageId":
				return ec.fieldContext_Article_coverImageId(ctx, field)
			case "createdAt":
				return ec.fieldContext_Article_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Article_deletedAt(ctx, field)
			case "id":
				return ec.fieldContext_Article_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Article_modifiedAt(ctx, field)
			case "project":
				return ec.fieldContext_Article_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Article_projectId(ctx, field)
			case "tags":
				return ec.fieldContext_Article_tags(ctx, field)
			case "title":
				return ec.fieldContext_Article_title(ctx, field)
			case "version":
				return ec.fieldContext_Article_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Article", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleFindList_items(ctx context.Context, field graphql.CollectedField, obj *model.ArticleFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleFindList_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Article)
	fc.Result = res
	return ec.marshalNArticle2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleFindList_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleFindList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "content":
				return ec.fieldContext_Article_content(ctx, field)
			case "coverImage":
				return ec.fieldContext_Article_coverImage(ctx, field)
			case "coverImageId":
				return ec.fieldContext_Article_coverImageId(ctx, field)
			case "createdAt":
				return ec.fieldContext_Article_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Article_deletedAt(ctx, field)
			case "id":
				return ec.fieldContext_Article_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Article_modifiedAt(ctx, field)
			case "project":
				return ec.fieldContext_Article_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Article_projectId(ctx, field)
			case "tags":
				return ec.fieldContext_Article_tags(ctx, field)
			case "title":
				return ec.fieldContext_Article_title(ctx, field)
			case "version":
				return ec.fieldContext_Article_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Article", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleFindList_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ArticleFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleFindList_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleFindList().TotalCount(rctx, obj, fc.Args["estimate"].(uint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TotalCountResolvingResult)
	fc.Result = res
	return ec.marshalNTotalCountResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTotalCountResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleFindList_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleFindList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TotalCountResolvingResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleFindList_totalCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleMutation_create(ctx context.Context, field graphql.CollectedField, obj *model.ArticleMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleMutation_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleMutation().Create(rctx, obj, fc.Args["input"].(model.ArticleCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleCreateResult)
	fc.Result = res
	return ec.marshalNArticleCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleCreateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleMutation_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleCreateResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleMutation_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleMutation_update(ctx context.Context, field graphql.CollectedField, obj *model.ArticleMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleMutation_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleMutation().Update(rctx, obj, fc.Args["input"].(model.ArticleUpdateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleUpdateResult)
	fc.Result = res
	return ec.marshalNArticleUpdateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleMutation_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleUpdateResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleMutation_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleNotFoundProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ArticleNotFoundProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleNotFoundProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleNotFoundProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleNotFoundProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleQuery_find(ctx context.Context, field graphql.CollectedField, obj *model.ArticleQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleQuery_find(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleQuery().Find(rctx, obj, fc.Args["filter"].(*model.ArticleFindFilterInput), fc.Args["sort"].(model.ArticleFindSortEnum), fc.Args["pageSize"].(uint), fc.Args["pageNumber"].(uint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleFindResult)
	fc.Result = res
	return ec.marshalNArticleFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleFindResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleQuery_find(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleFindResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleQuery_find_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTag_articleID(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTag_articleID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArticleID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTag_articleID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTag_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTag_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTag_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTag_id(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTag_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTag_modifiedAt(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTag_modifiedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTag_modifiedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTag_sortRank(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTag_sortRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTag_sortRank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTag_tag(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTag_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleTag().Tag(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TagResolvingResult)
	fc.Result = res
	return ec.marshalNTagResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTag_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TagResolvingResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTag_tagId(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTag_tagId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TagID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTag_tagId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTag_version(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTag_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTag_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTagAlreadyExistsProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTagAlreadyExistsProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTagAlreadyExistsProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTagAlreadyExistsProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTagAlreadyExistsProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTagCreateOk_articleTag(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTagCreateOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTagCreateOk_articleTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArticleTag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ArticleTag)
	fc.Result = res
	return ec.marshalNArticleTag2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTagCreateOk_articleTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTagCreateOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "articleID":
				return ec.fieldContext_ArticleTag_articleID(ctx, field)
			case "createdAt":
				return ec.fieldContext_ArticleTag_createdAt(ctx, field)
			case "id":
				return ec.fieldContext_ArticleTag_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_ArticleTag_modifiedAt(ctx, field)
			case "sortRank":
				return ec.fieldContext_ArticleTag_sortRank(ctx, field)
			case "tag":
				return ec.fieldContext_ArticleTag_tag(ctx, field)
			case "tagId":
				return ec.fieldContext_ArticleTag_tagId(ctx, field)
			case "version":
				return ec.fieldContext_ArticleTag_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArticleTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTagList_items(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTagList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTagList_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ArticleTag)
	fc.Result = res
	return ec.marshalNArticleTag2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTagList_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTagList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "articleID":
				return ec.fieldContext_ArticleTag_articleID(ctx, field)
			case "createdAt":
				return ec.fieldContext_ArticleTag_createdAt(ctx, field)
			case "id":
				return ec.fieldContext_ArticleTag_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_ArticleTag_modifiedAt(ctx, field)
			case "sortRank":
				return ec.fieldContext_ArticleTag_sortRank(ctx, field)
			case "tag":
				return ec.fieldContext_ArticleTag_tag(ctx, field)
			case "tagId":
				return ec.fieldContext_ArticleTag_tagId(ctx, field)
			case "version":
				return ec.fieldContext_ArticleTag_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArticleTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTagMoveOk_sortRank(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTagMoveOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTagMoveOk_sortRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTagMoveOk_sortRank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTagMoveOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTagMoveOk_version(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTagMoveOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTagMoveOk_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTagMoveOk_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTagMoveOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTagMutation_create(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTagMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTagMutation_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleTagMutation().Create(rctx, obj, fc.Args["input"].(model.ArticleTagCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleTagCreateResult)
	fc.Result = res
	return ec.marshalNArticleTagCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagCreateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTagMutation_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTagMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleTagCreateResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleTagMutation_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTagMutation_move(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTagMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTagMutation_move(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ArticleTagMutation().Move(rctx, obj, fc.Args["input"].(model.ArticleTagMoveInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ArticleTagMoveResult)
	fc.Result = res
	return ec.marshalNArticleTagMoveResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagMoveResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTagMutation_move(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTagMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArticleTagMoveResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ArticleTagMutation_move_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ArticleTagNotFoundProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ArticleTagNotFoundProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleTagNotFoundProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleTagNotFoundProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleTagNotFoundProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArticleUpdateOk_article(ctx context.Context, field graphql.CollectedField, obj *model.ArticleUpdateOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArticleUpdateOk_article(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Article, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Article)
	fc.Result = res
	return ec.marshalNArticle2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArticleUpdateOk_article(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArticleUpdateOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "content":
				return ec.fieldContext_Article_content(ctx, field)
			case "coverImage":
				return ec.fieldContext_Article_coverImage(ctx, field)
			case "coverImageId":
				return ec.fieldContext_Article_coverImageId(ctx, field)
			case "createdAt":
				return ec.fieldContext_Article_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Article_deletedAt(ctx, field)
			case "id":
				return ec.fieldContext_Article_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Article_modifiedAt(ctx, field)
			case "project":
				return ec.fieldContext_Article_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Article_projectId(ctx, field)
			case "tags":
				return ec.fieldContext_Article_tags(ctx, field)
			case "title":
				return ec.fieldContext_Article_title(ctx, field)
			case "version":
				return ec.fieldContext_Article_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Article", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_assets(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_assets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Assets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ImageAsset)
	fc.Result = res
	return ec.marshalNImageAsset2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAssetᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_assets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "format":
				return ec.fieldContext_ImageAsset_format(ctx, field)
			case "width":
				return ec.fieldContext_ImageAsset_width(ctx, field)
			case "url":
				return ec.fieldContext_ImageAsset_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageAsset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalORfc3339Date2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_type(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_height(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_id(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_modifiedAt(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_modifiedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_modifiedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_download(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_download(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Download(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ImageDownloadResolvingResult)
	fc.Result = res
	return ec.marshalNImageDownloadResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageDownloadResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_download(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageDownloadResolvingResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_version(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_width(ctx context.Context, field graphql.CollectedField, obj *model.Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_width(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageAsset_format(ctx context.Context, field graphql.CollectedField, obj *model.ImageAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageAsset_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ImageAssetFormat)
	fc.Result = res
	return ec.marshalNImageAssetFormat2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAssetFormat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageAsset_format(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageAssetFormat does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageAsset_width(ctx context.Context, field graphql.CollectedField, obj *model.ImageAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageAsset_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ImageAssetWidth)
	fc.Result = res
	return ec.marshalNImageAssetWidth2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAssetWidth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageAsset_width(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageAssetWidth does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageAsset_url(ctx context.Context, field graphql.CollectedField, obj *model.ImageAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageAsset_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(url.URL)
	fc.Result = res
	return ec.marshalNUrl2netᚋurlᚐURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageAsset_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageDownload_url(ctx context.Context, field graphql.CollectedField, obj *model.ImageDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageDownload_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(url.URL)
	fc.Result = res
	return ec.marshalNUrl2netᚋurlᚐURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageDownload_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageFindList_items(ctx context.Context, field graphql.CollectedField, obj *model.ImageFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageFindList_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Image)
	fc.Result = res
	return ec.marshalNImage2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageFindList_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageFindList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assets":
				return ec.fieldContext_Image_assets(ctx, field)
			case "createdAt":
				return ec.fieldContext_Image_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Image_deletedAt(ctx, field)
			case "type":
				return ec.fieldContext_Image_type(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Image_modifiedAt(ctx, field)
			case "download":
				return ec.fieldContext_Image_download(ctx, field)
			case "version":
				return ec.fieldContext_Image_version(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageFindList_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ImageFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageFindList_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ImageFindList().TotalCount(rctx, obj, fc.Args["estimate"].(uint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TotalCountResolvingResult)
	fc.Result = res
	return ec.marshalNTotalCountResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTotalCountResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageFindList_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageFindList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TotalCountResolvingResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ImageFindList_totalCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImageMutation_upload(ctx context.Context, field graphql.CollectedField, obj *model.ImageMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMutation_upload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ImageMutation().Upload(rctx, obj, fc.Args["input"].(model.ImageUploadInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ImageUploadResult)
	fc.Result = res
	return ec.marshalNImageUploadResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageUploadResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMutation_upload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageUploadResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ImageMutation_upload_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImageNotFoundProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ImageNotFoundProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageNotFoundProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageNotFoundProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageNotFoundProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageNotRecognizedProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ImageNotRecognizedProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageNotRecognizedProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageNotRecognizedProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageNotRecognizedProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageNotSupportedTypeProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ImageNotSupportedTypeProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageNotSupportedTypeProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageNotSupportedTypeProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageNotSupportedTypeProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageQuery_find(ctx context.Context, field graphql.CollectedField, obj *model.ImageQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageQuery_find(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ImageQuery().Find(rctx, obj, fc.Args["filter"].(*model.ImageFindFilterInput), fc.Args["sort"].(model.ImageFindSortEnum), fc.Args["pageSize"].(uint), fc.Args["pageNumber"].(uint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ImageFindResult)
	fc.Result = res
	return ec.marshalNImageFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageFindResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageQuery_find(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageFindResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ImageQuery_find_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImageUploadOk_image(ctx context.Context, field graphql.CollectedField, obj *model.ImageUploadOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageUploadOk_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Image)
	fc.Result = res
	return ec.marshalNImage2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageUploadOk_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageUploadOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assets":
				return ec.fieldContext_Image_assets(ctx, field)
			case "createdAt":
				return ec.fieldContext_Image_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Image_deletedAt(ctx, field)
			case "type":
				return ec.fieldContext_Image_type(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Image_modifiedAt(ctx, field)
			case "download":
				return ec.fieldContext_Image_download(ctx, field)
			case "version":
				return ec.fieldContext_Image_version(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InternalErrorProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.InternalErrorProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InternalErrorProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InternalErrorProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InternalErrorProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidSortRankProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.InvalidSortRankProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidSortRankProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidSortRankProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidSortRankProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_articleBlock(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_articleBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ArticleBlock(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ArticleBlockMutation)
	fc.Result = res
	return ec.marshalNArticleBlockMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_articleBlock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "create":
				return ec.fieldContext_ArticleBlockMutation_create(ctx, field)
			case "move":
				return ec.fieldContext_ArticleBlockMutation_move(ctx, field)
			case "update":
				return ec.fieldContext_ArticleBlockMutation_update(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArticleBlockMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_article(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_article(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Article(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ArticleMutation)
	fc.Result = res
	return ec.marshalNArticleMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_article(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "create":
				return ec.fieldContext_ArticleMutation_create(ctx, field)
			case "update":
				return ec.fieldContext_ArticleMutation_update(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArticleMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_articleTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_articleTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ArticleTag(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ArticleTagMutation)
	fc.Result = res
	return ec.marshalNArticleTagMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_articleTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "create":
				return ec.fieldContext_ArticleTagMutation_create(ctx, field)
			case "move":
				return ec.fieldContext_ArticleTagMutation_move(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArticleTagMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_image(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Image(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageMutation)
	fc.Result = res
	return ec.marshalNImageMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "upload":
				return ec.fieldContext_ImageMutation_upload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_project(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Project(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ProjectMutation)
	fc.Result = res
	return ec.marshalNProjectMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "create":
				return ec.fieldContext_ProjectMutation_create(ctx, field)
			case "update":
				return ec.fieldContext_ProjectMutation_update(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_tag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Tag(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TagMutation)
	fc.Result = res
	return ec.marshalNTagMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "create":
				return ec.fieldContext_TagMutation_create(ctx, field)
			case "update":
				return ec.fieldContext_TagMutation_update(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalORfc3339Date2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_id(ctx context.Context, field graphql.CollectedField, obj *model.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_modifiedAt(ctx context.Context, field graphql.CollectedField, obj *model.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_modifiedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_modifiedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_name(ctx context.Context, field graphql.CollectedField, obj *model.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_version(ctx context.Context, field graphql.CollectedField, obj *model.Project) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlreadyExistsProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ProjectAlreadyExistsProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlreadyExistsProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlreadyExistsProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlreadyExistsProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectCreateOk_project(ctx context.Context, field graphql.CollectedField, obj *model.ProjectCreateOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectCreateOk_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Project)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectCreateOk_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectCreateOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Project_deletedAt(ctx, field)
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Project_modifiedAt(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "version":
				return ec.fieldContext_Project_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectFindList_items(ctx context.Context, field graphql.CollectedField, obj *model.ProjectFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectFindList_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Project)
	fc.Result = res
	return ec.marshalNProject2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectFindList_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectFindList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Project_deletedAt(ctx, field)
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Project_modifiedAt(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "version":
				return ec.fieldContext_Project_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectFindList_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ProjectFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectFindList_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectFindList().TotalCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TotalCountResolvingResult)
	fc.Result = res
	return ec.marshalNTotalCountResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTotalCountResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectFindList_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectFindList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TotalCountResolvingResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectMutation_create(ctx context.Context, field graphql.CollectedField, obj *model.ProjectMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectMutation_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectMutation().Create(rctx, obj, fc.Args["input"].(model.ProjectCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProjectCreateResult)
	fc.Result = res
	return ec.marshalNProjectCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectCreateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectMutation_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectCreateResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ProjectMutation_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ProjectMutation_update(ctx context.Context, field graphql.CollectedField, obj *model.ProjectMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectMutation_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectMutation().Update(rctx, obj, fc.Args["input"].(model.ProjectUpdateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProjectUpdateResult)
	fc.Result = res
	return ec.marshalNProjectUpdateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectMutation_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectUpdateResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ProjectMutation_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ProjectNotFoundProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.ProjectNotFoundProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectNotFoundProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectNotFoundProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectNotFoundProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectQuery_find(ctx context.Context, field graphql.CollectedField, obj *model.ProjectQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectQuery_find(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectQuery().Find(rctx, obj, fc.Args["filter"].(*model.ProjectFindFilterInput), fc.Args["sort"].(model.ProjectFindSortEnum), fc.Args["pageSize"].(uint), fc.Args["pageNumber"].(uint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProjectFindResult)
	fc.Result = res
	return ec.marshalNProjectFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectFindResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectQuery_find(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectFindResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ProjectQuery_find_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ProjectUpdateOk_project(ctx context.Context, field graphql.CollectedField, obj *model.ProjectUpdateOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectUpdateOk_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Project)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectUpdateOk_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectUpdateOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_Project_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Project_deletedAt(ctx, field)
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Project_modifiedAt(ctx, field)
			case "name":
				return ec.fieldContext_Project_name(ctx, field)
			case "version":
				return ec.fieldContext_Project_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_articleBlock(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_articleBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ArticleBlock(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ArticleBlockQuery)
	fc.Result = res
	return ec.marshalNArticleBlockQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_articleBlock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "find":
				return ec.fieldContext_ArticleBlockQuery_find(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArticleBlockQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_article(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_article(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Article(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ArticleQuery)
	fc.Result = res
	return ec.marshalNArticleQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_article(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "find":
				return ec.fieldContext_ArticleQuery_find(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArticleQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_image(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Image(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageQuery)
	fc.Result = res
	return ec.marshalNImageQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "find":
				return ec.fieldContext_ImageQuery_find(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_project(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Project(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ProjectQuery)
	fc.Result = res
	return ec.marshalNProjectQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "find":
				return ec.fieldContext_ProjectQuery_find(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_tag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tag(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TagQuery)
	fc.Result = res
	return ec.marshalNTagQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "find":
				return ec.fieldContext_TagQuery_find(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_articleBlockCreated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_articleBlockCreated(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ArticleBlockCreated(rctx, fc.Args["articleId"].(uuid.UUID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan model.ArticleBlockInterface):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNArticleBlockInterface2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockInterface(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_articleBlockCreated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_articleBlockCreated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Tag_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalORfc3339Date2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *model.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uuid does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_modifiedAt(ctx context.Context, field graphql.CollectedField, obj *model.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_modifiedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModifiedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNRfc3339Date2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_modifiedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Rfc3339Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *model.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_version(ctx context.Context, field graphql.CollectedField, obj *model.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagAlreadyExistsProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.TagAlreadyExistsProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagAlreadyExistsProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagAlreadyExistsProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagAlreadyExistsProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagCreateOk_tag(ctx context.Context, field graphql.CollectedField, obj *model.TagCreateOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagCreateOk_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tag)
	fc.Result = res
	return ec.marshalNTag2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagCreateOk_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagCreateOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_Tag_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Tag_deletedAt(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Tag_modifiedAt(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "version":
				return ec.fieldContext_Tag_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagFindList_items(ctx context.Context, field graphql.CollectedField, obj *model.TagFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagFindList_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Tag)
	fc.Result = res
	return ec.marshalNTag2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagFindList_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagFindList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_Tag_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Tag_deletedAt(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Tag_modifiedAt(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "version":
				return ec.fieldContext_Tag_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagFindList_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.TagFindList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagFindList_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TagFindList().TotalCount(rctx, obj, fc.Args["estimate"].(uint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TotalCountResolvingResult)
	fc.Result = res
	return ec.marshalNTotalCountResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTotalCountResolvingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagFindList_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagFindList",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TotalCountResolvingResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TagFindList_totalCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TagMutation_create(ctx context.Context, field graphql.CollectedField, obj *model.TagMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagMutation_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TagMutation().Create(rctx, obj, fc.Args["input"].(model.TagCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TagCreateResult)
	fc.Result = res
	return ec.marshalNTagCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagCreateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagMutation_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TagCreateResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TagMutation_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TagMutation_update(ctx context.Context, field graphql.CollectedField, obj *model.TagMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagMutation_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TagMutation().Update(rctx, obj, fc.Args["input"].(model.TagUpdateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TagUpdateResult)
	fc.Result = res
	return ec.marshalNTagUpdateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagMutation_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TagUpdateResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TagMutation_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TagNotFoundProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.TagNotFoundProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagNotFoundProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagNotFoundProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagNotFoundProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagQuery_find(ctx context.Context, field graphql.CollectedField, obj *model.TagQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagQuery_find(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TagQuery().Find(rctx, obj, fc.Args["filter"].(*model.TagFindFilterInput), fc.Args["sort"].(model.TagFindSortEnum), fc.Args["pageSize"].(uint), fc.Args["pageNumber"].(uint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TagFindResult)
	fc.Result = res
	return ec.marshalNTagFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagFindResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagQuery_find(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TagFindResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TagQuery_find_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TagUpdateOk_tag(ctx context.Context, field graphql.CollectedField, obj *model.TagUpdateOk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagUpdateOk_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tag)
	fc.Result = res
	return ec.marshalNTag2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagUpdateOk_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagUpdateOk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_Tag_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Tag_deletedAt(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "modifiedAt":
				return ec.fieldContext_Tag_modifiedAt(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "version":
				return ec.fieldContext_Tag_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TotalCount_value(ctx context.Context, field graphql.CollectedField, obj *model.TotalCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TotalCount_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUInt2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TotalCount_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TotalCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionMismatchProblem_message(ctx context.Context, field graphql.CollectedField, obj *model.VersionMismatchProblem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionMismatchProblem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionMismatchProblem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionMismatchProblem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputArticleBlockCreateInput(ctx context.Context, obj interface{}) (model.ArticleBlockCreateInput, error) {
	var it model.ArticleBlockCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"articleId", "blockType", "sortRank"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "articleId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("articleId"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ArticleID = data
		case "blockType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockType"))
			data, err := ec.unmarshalNArticleBlockTypeEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockTypeEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockType = data
		case "sortRank":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortRank"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalNSortRankInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐSortRankInput(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.SortRankInput == nil {
					return nil, errors.New("directive sortRankInput is not implemented")
				}
				return ec.directives.SortRankInput(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.SortRankInput); ok {
				it.SortRank = data
			} else if tmp == nil {
				it.SortRank = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/acelot/articles/internal/gql/model.SortRankInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleBlockDataInput(ctx context.Context, obj interface{}) (model.ArticleBlockDataInput, error) {
	var it model.ArticleBlockDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"html", "image"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "html":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("html"))
			data, err := ec.unmarshalOArticleBlockHtmlDataInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockHTMLDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HTML = data
		case "image":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image"))
			data, err := ec.unmarshalOArticleBlockImageDataInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockImageDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Image = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleBlockFindFilterInput(ctx context.Context, obj interface{}) (model.ArticleBlockFindFilterInput, error) {
	var it model.ArticleBlockFindFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"articleIdAnyOf", "idAnyOf", "typeAnyOf"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "articleIdAnyOf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("articleIdAnyOf"))
			data, err := ec.unmarshalOUuid2ᚕgithubᚗcomᚋgoogleᚋuuidᚐUUIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ArticleIDAnyOf = data
		case "idAnyOf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idAnyOf"))
			data, err := ec.unmarshalOUuid2ᚕgithubᚗcomᚋgoogleᚋuuidᚐUUIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDAnyOf = data
		case "typeAnyOf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeAnyOf"))
			data, err := ec.unmarshalOArticleBlockTypeEnum2ᚕgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockTypeEnumᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeAnyOf = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleBlockHtmlDataInput(ctx context.Context, obj interface{}) (model.ArticleBlockHTMLDataInput, error) {
	var it model.ArticleBlockHTMLDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"body"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "body":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("body"))
			data, err := ec.unmarshalNHtml2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Body = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleBlockImageDataInput(ctx context.Context, obj interface{}) (model.ArticleBlockImageDataInput, error) {
	var it model.ArticleBlockImageDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"imageId", "copyright", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "imageId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageId"))
			data, err := ec.unmarshalOUuid2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageID = data
		case "copyright":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("copyright"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Copyright = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOHtml2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleBlockMoveInput(ctx context.Context, obj interface{}) (model.ArticleBlockMoveInput, error) {
	var it model.ArticleBlockMoveInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "sortRank", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "sortRank":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortRank"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalNSortRankInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐSortRankInput(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.SortRankInput == nil {
					return nil, errors.New("directive sortRankInput is not implemented")
				}
				return ec.directives.SortRankInput(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.SortRankInput); ok {
				it.SortRank = data
			} else if tmp == nil {
				it.SortRank = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/acelot/articles/internal/gql/model.SortRankInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNUInt2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleBlockUpdateInput(ctx context.Context, obj interface{}) (model.ArticleBlockUpdateInput, error) {
	var it model.ArticleBlockUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "data", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalNArticleBlockDataInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockDataInput(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.InputUnion == nil {
					return nil, errors.New("directive inputUnion is not implemented")
				}
				return ec.directives.InputUnion(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.ArticleBlockDataInput); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/acelot/articles/internal/gql/model.ArticleBlockDataInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNUInt2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleCreateInput(ctx context.Context, obj interface{}) (model.ArticleCreateInput, error) {
	var it model.ArticleCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleFindFilterInput(ctx context.Context, obj interface{}) (model.ArticleFindFilterInput, error) {
	var it model.ArticleFindFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"idAnyOf"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "idAnyOf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idAnyOf"))
			data, err := ec.unmarshalOUuid2ᚕgithubᚗcomᚋgoogleᚋuuidᚐUUIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDAnyOf = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleTagCreateInput(ctx context.Context, obj interface{}) (model.ArticleTagCreateInput, error) {
	var it model.ArticleTagCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"articleId", "tagId", "sortRank"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "articleId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("articleId"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ArticleID = data
		case "tagId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagId"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagID = data
		case "sortRank":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortRank"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalNSortRankInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐSortRankInput(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.SortRankInput == nil {
					return nil, errors.New("directive sortRankInput is not implemented")
				}
				return ec.directives.SortRankInput(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.SortRankInput); ok {
				it.SortRank = data
			} else if tmp == nil {
				it.SortRank = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/acelot/articles/internal/gql/model.SortRankInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleTagMoveInput(ctx context.Context, obj interface{}) (model.ArticleTagMoveInput, error) {
	var it model.ArticleTagMoveInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "sortRank", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "sortRank":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortRank"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalNSortRankInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐSortRankInput(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.SortRankInput == nil {
					return nil, errors.New("directive sortRankInput is not implemented")
				}
				return ec.directives.SortRankInput(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.SortRankInput); ok {
				it.SortRank = data
			} else if tmp == nil {
				it.SortRank = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/acelot/articles/internal/gql/model.SortRankInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNUInt2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArticleUpdateInput(ctx context.Context, obj interface{}) (model.ArticleUpdateInput, error) {
	var it model.ArticleUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "coverImageId", "title", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "coverImageId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverImageId"))
			data, err := ec.unmarshalOUuid2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageID = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNUInt2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageFindFilterInput(ctx context.Context, obj interface{}) (model.ImageFindFilterInput, error) {
	var it model.ImageFindFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"idAnyOf"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "idAnyOf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idAnyOf"))
			data, err := ec.unmarshalOUuid2ᚕgithubᚗcomᚋgoogleᚋuuidᚐUUIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDAnyOf = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageUploadInput(ctx context.Context, obj interface{}) (model.ImageUploadInput, error) {
	var it model.ImageUploadInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"file"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "file":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
			data, err := ec.unmarshalOUpload2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.File = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectCreateInput(ctx context.Context, obj interface{}) (model.ProjectCreateInput, error) {
	var it model.ProjectCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectFindFilterInput(ctx context.Context, obj interface{}) (model.ProjectFindFilterInput, error) {
	var it model.ProjectFindFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"idAnyOf"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "idAnyOf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idAnyOf"))
			data, err := ec.unmarshalOUuid2ᚕgithubᚗcomᚋgoogleᚋuuidᚐUUIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDAnyOf = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectUpdateInput(ctx context.Context, obj interface{}) (model.ProjectUpdateInput, error) {
	var it model.ProjectUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNUInt2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSortRankInput(ctx context.Context, obj interface{}) (model.SortRankInput, error) {
	var it model.SortRankInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["prev"]; !present {
		asMap["prev"] = "0"
	}
	if _, present := asMap["next"]; !present {
		asMap["next"] = "z"
	}

	fieldsInOrder := [...]string{"prev", "next"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "prev":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prev"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Prev = data
		case "next":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Next = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagCreateInput(ctx context.Context, obj interface{}) (model.TagCreateInput, error) {
	var it model.TagCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagFindFilterInput(ctx context.Context, obj interface{}) (model.TagFindFilterInput, error) {
	var it model.TagFindFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"idAnyOf"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "idAnyOf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idAnyOf"))
			data, err := ec.unmarshalOUuid2ᚕgithubᚗcomᚋgoogleᚋuuidᚐUUIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDAnyOf = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagUpdateInput(ctx context.Context, obj interface{}) (model.TagUpdateInput, error) {
	var it model.TagUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNUInt2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ArticleBlockCreateResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleBlockCreateResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ArticleNotFoundProblem:
		return ec._ArticleNotFoundProblem(ctx, sel, &obj)
	case *model.ArticleNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleNotFoundProblem(ctx, sel, obj)
	case model.InvalidSortRankProblem:
		return ec._InvalidSortRankProblem(ctx, sel, &obj)
	case *model.InvalidSortRankProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidSortRankProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleBlockCreateOk:
		return ec._ArticleBlockCreateOk(ctx, sel, &obj)
	case *model.ArticleBlockCreateOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockCreateOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleBlockFindResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleBlockFindResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleBlockFindList:
		return ec._ArticleBlockFindList(ctx, sel, &obj)
	case *model.ArticleBlockFindList:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockFindList(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleBlockInterface(ctx context.Context, sel ast.SelectionSet, obj model.ArticleBlockInterface) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ArticleBlockHTML:
		return ec._ArticleBlockHtml(ctx, sel, &obj)
	case *model.ArticleBlockHTML:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockHtml(ctx, sel, obj)
	case model.ArticleBlockImage:
		return ec._ArticleBlockImage(ctx, sel, &obj)
	case *model.ArticleBlockImage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockImage(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleBlockMoveResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleBlockMoveResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ArticleBlockNotFoundProblem:
		return ec._ArticleBlockNotFoundProblem(ctx, sel, &obj)
	case *model.ArticleBlockNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockNotFoundProblem(ctx, sel, obj)
	case model.InvalidSortRankProblem:
		return ec._InvalidSortRankProblem(ctx, sel, &obj)
	case *model.InvalidSortRankProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidSortRankProblem(ctx, sel, obj)
	case model.VersionMismatchProblem:
		return ec._VersionMismatchProblem(ctx, sel, &obj)
	case *model.VersionMismatchProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._VersionMismatchProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleBlockMoveOk:
		return ec._ArticleBlockMoveOk(ctx, sel, &obj)
	case *model.ArticleBlockMoveOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockMoveOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleBlockUpdateResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleBlockUpdateResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ArticleBlockNotFoundProblem:
		return ec._ArticleBlockNotFoundProblem(ctx, sel, &obj)
	case *model.ArticleBlockNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockNotFoundProblem(ctx, sel, obj)
	case model.ArticleBlockTypeMismatchProblem:
		return ec._ArticleBlockTypeMismatchProblem(ctx, sel, &obj)
	case *model.ArticleBlockTypeMismatchProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockTypeMismatchProblem(ctx, sel, obj)
	case model.VersionMismatchProblem:
		return ec._VersionMismatchProblem(ctx, sel, &obj)
	case *model.VersionMismatchProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._VersionMismatchProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleBlockUpdateOk:
		return ec._ArticleBlockUpdateOk(ctx, sel, &obj)
	case *model.ArticleBlockUpdateOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockUpdateOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleContentResolvingResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleContentResolvingResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleContent:
		return ec._ArticleContent(ctx, sel, &obj)
	case *model.ArticleContent:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleContent(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleCreateResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleCreateResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ProjectNotFoundProblem:
		return ec._ProjectNotFoundProblem(ctx, sel, &obj)
	case *model.ProjectNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectNotFoundProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleCreateOk:
		return ec._ArticleCreateOk(ctx, sel, &obj)
	case *model.ArticleCreateOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleCreateOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleFindResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleFindResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleFindList:
		return ec._ArticleFindList(ctx, sel, &obj)
	case *model.ArticleFindList:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleFindList(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleTagCreateResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleTagCreateResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ArticleNotFoundProblem:
		return ec._ArticleNotFoundProblem(ctx, sel, &obj)
	case *model.ArticleNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleNotFoundProblem(ctx, sel, obj)
	case model.TagNotFoundProblem:
		return ec._TagNotFoundProblem(ctx, sel, &obj)
	case *model.TagNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagNotFoundProblem(ctx, sel, obj)
	case model.ArticleTagAlreadyExistsProblem:
		return ec._ArticleTagAlreadyExistsProblem(ctx, sel, &obj)
	case *model.ArticleTagAlreadyExistsProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleTagAlreadyExistsProblem(ctx, sel, obj)
	case model.InvalidSortRankProblem:
		return ec._InvalidSortRankProblem(ctx, sel, &obj)
	case *model.InvalidSortRankProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidSortRankProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleTagCreateOk:
		return ec._ArticleTagCreateOk(ctx, sel, &obj)
	case *model.ArticleTagCreateOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleTagCreateOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleTagMoveResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleTagMoveResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ArticleTagNotFoundProblem:
		return ec._ArticleTagNotFoundProblem(ctx, sel, &obj)
	case *model.ArticleTagNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleTagNotFoundProblem(ctx, sel, obj)
	case model.InvalidSortRankProblem:
		return ec._InvalidSortRankProblem(ctx, sel, &obj)
	case *model.InvalidSortRankProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidSortRankProblem(ctx, sel, obj)
	case model.VersionMismatchProblem:
		return ec._VersionMismatchProblem(ctx, sel, &obj)
	case *model.VersionMismatchProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._VersionMismatchProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleTagMoveOk:
		return ec._ArticleTagMoveOk(ctx, sel, &obj)
	case *model.ArticleTagMoveOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleTagMoveOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleTagsResolvingResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleTagsResolvingResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleTagList:
		return ec._ArticleTagList(ctx, sel, &obj)
	case *model.ArticleTagList:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleTagList(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ArticleUpdateResult(ctx context.Context, sel ast.SelectionSet, obj model.ArticleUpdateResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ArticleNotFoundProblem:
		return ec._ArticleNotFoundProblem(ctx, sel, &obj)
	case *model.ArticleNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleNotFoundProblem(ctx, sel, obj)
	case model.VersionMismatchProblem:
		return ec._VersionMismatchProblem(ctx, sel, &obj)
	case *model.VersionMismatchProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._VersionMismatchProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ArticleUpdateOk:
		return ec._ArticleUpdateOk(ctx, sel, &obj)
	case *model.ArticleUpdateOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleUpdateOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ImageDownloadResolvingResult(ctx context.Context, sel ast.SelectionSet, obj model.ImageDownloadResolvingResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ImageDownload:
		return ec._ImageDownload(ctx, sel, &obj)
	case *model.ImageDownload:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageDownload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ImageFindResult(ctx context.Context, sel ast.SelectionSet, obj model.ImageFindResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ImageFindList:
		return ec._ImageFindList(ctx, sel, &obj)
	case *model.ImageFindList:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageFindList(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ImageResolvingResult(ctx context.Context, sel ast.SelectionSet, obj model.ImageResolvingResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Image:
		return ec._Image(ctx, sel, &obj)
	case *model.Image:
		if obj == nil {
			return graphql.Null
		}
		return ec._Image(ctx, sel, obj)
	case model.ImageNotFoundProblem:
		return ec._ImageNotFoundProblem(ctx, sel, &obj)
	case *model.ImageNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageNotFoundProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ImageUploadResult(ctx context.Context, sel ast.SelectionSet, obj model.ImageUploadResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ImageNotSupportedTypeProblem:
		return ec._ImageNotSupportedTypeProblem(ctx, sel, &obj)
	case *model.ImageNotSupportedTypeProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageNotSupportedTypeProblem(ctx, sel, obj)
	case model.ImageNotRecognizedProblem:
		return ec._ImageNotRecognizedProblem(ctx, sel, &obj)
	case *model.ImageNotRecognizedProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageNotRecognizedProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ImageUploadOk:
		return ec._ImageUploadOk(ctx, sel, &obj)
	case *model.ImageUploadOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageUploadOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ProblemInterface(ctx context.Context, sel ast.SelectionSet, obj model.ProblemInterface) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ArticleNotFoundProblem:
		return ec._ArticleNotFoundProblem(ctx, sel, &obj)
	case *model.ArticleNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleNotFoundProblem(ctx, sel, obj)
	case model.ArticleBlockNotFoundProblem:
		return ec._ArticleBlockNotFoundProblem(ctx, sel, &obj)
	case *model.ArticleBlockNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockNotFoundProblem(ctx, sel, obj)
	case model.ArticleBlockTypeMismatchProblem:
		return ec._ArticleBlockTypeMismatchProblem(ctx, sel, &obj)
	case *model.ArticleBlockTypeMismatchProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockTypeMismatchProblem(ctx, sel, obj)
	case model.ArticleTagNotFoundProblem:
		return ec._ArticleTagNotFoundProblem(ctx, sel, &obj)
	case *model.ArticleTagNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleTagNotFoundProblem(ctx, sel, obj)
	case model.ArticleTagAlreadyExistsProblem:
		return ec._ArticleTagAlreadyExistsProblem(ctx, sel, &obj)
	case *model.ArticleTagAlreadyExistsProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleTagAlreadyExistsProblem(ctx, sel, obj)
	case model.ImageNotFoundProblem:
		return ec._ImageNotFoundProblem(ctx, sel, &obj)
	case *model.ImageNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageNotFoundProblem(ctx, sel, obj)
	case model.ImageNotSupportedTypeProblem:
		return ec._ImageNotSupportedTypeProblem(ctx, sel, &obj)
	case *model.ImageNotSupportedTypeProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageNotSupportedTypeProblem(ctx, sel, obj)
	case model.ImageNotRecognizedProblem:
		return ec._ImageNotRecognizedProblem(ctx, sel, &obj)
	case *model.ImageNotRecognizedProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageNotRecognizedProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ProjectNotFoundProblem:
		return ec._ProjectNotFoundProblem(ctx, sel, &obj)
	case *model.ProjectNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectNotFoundProblem(ctx, sel, obj)
	case model.ProjectAlreadyExistsProblem:
		return ec._ProjectAlreadyExistsProblem(ctx, sel, &obj)
	case *model.ProjectAlreadyExistsProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectAlreadyExistsProblem(ctx, sel, obj)
	case model.InvalidSortRankProblem:
		return ec._InvalidSortRankProblem(ctx, sel, &obj)
	case *model.InvalidSortRankProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidSortRankProblem(ctx, sel, obj)
	case model.TagNotFoundProblem:
		return ec._TagNotFoundProblem(ctx, sel, &obj)
	case *model.TagNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagNotFoundProblem(ctx, sel, obj)
	case model.TagAlreadyExistsProblem:
		return ec._TagAlreadyExistsProblem(ctx, sel, &obj)
	case *model.TagAlreadyExistsProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagAlreadyExistsProblem(ctx, sel, obj)
	case model.VersionMismatchProblem:
		return ec._VersionMismatchProblem(ctx, sel, &obj)
	case *model.VersionMismatchProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._VersionMismatchProblem(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ProjectCreateResult(ctx context.Context, sel ast.SelectionSet, obj model.ProjectCreateResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ProjectAlreadyExistsProblem:
		return ec._ProjectAlreadyExistsProblem(ctx, sel, &obj)
	case *model.ProjectAlreadyExistsProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectAlreadyExistsProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ProjectCreateOk:
		return ec._ProjectCreateOk(ctx, sel, &obj)
	case *model.ProjectCreateOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectCreateOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ProjectFindResult(ctx context.Context, sel ast.SelectionSet, obj model.ProjectFindResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ProjectFindList:
		return ec._ProjectFindList(ctx, sel, &obj)
	case *model.ProjectFindList:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectFindList(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ProjectResolvingResult(ctx context.Context, sel ast.SelectionSet, obj model.ProjectResolvingResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Project:
		return ec._Project(ctx, sel, &obj)
	case *model.Project:
		if obj == nil {
			return graphql.Null
		}
		return ec._Project(ctx, sel, obj)
	case model.ProjectNotFoundProblem:
		return ec._ProjectNotFoundProblem(ctx, sel, &obj)
	case *model.ProjectNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectNotFoundProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ProjectUpdateResult(ctx context.Context, sel ast.SelectionSet, obj model.ProjectUpdateResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ProjectNotFoundProblem:
		return ec._ProjectNotFoundProblem(ctx, sel, &obj)
	case *model.ProjectNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectNotFoundProblem(ctx, sel, obj)
	case model.VersionMismatchProblem:
		return ec._VersionMismatchProblem(ctx, sel, &obj)
	case *model.VersionMismatchProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._VersionMismatchProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.ProjectUpdateOk:
		return ec._ProjectUpdateOk(ctx, sel, &obj)
	case *model.ProjectUpdateOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProjectUpdateOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TagCreateResult(ctx context.Context, sel ast.SelectionSet, obj model.TagCreateResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.TagAlreadyExistsProblem:
		return ec._TagAlreadyExistsProblem(ctx, sel, &obj)
	case *model.TagAlreadyExistsProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagAlreadyExistsProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.TagCreateOk:
		return ec._TagCreateOk(ctx, sel, &obj)
	case *model.TagCreateOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagCreateOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TagFindResult(ctx context.Context, sel ast.SelectionSet, obj model.TagFindResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.TagFindList:
		return ec._TagFindList(ctx, sel, &obj)
	case *model.TagFindList:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagFindList(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TagResolvingResult(ctx context.Context, sel ast.SelectionSet, obj model.TagResolvingResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Tag:
		return ec._Tag(ctx, sel, &obj)
	case *model.Tag:
		if obj == nil {
			return graphql.Null
		}
		return ec._Tag(ctx, sel, obj)
	case model.TagNotFoundProblem:
		return ec._TagNotFoundProblem(ctx, sel, &obj)
	case *model.TagNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagNotFoundProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TagUpdateResult(ctx context.Context, sel ast.SelectionSet, obj model.TagUpdateResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.TagNotFoundProblem:
		return ec._TagNotFoundProblem(ctx, sel, &obj)
	case *model.TagNotFoundProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagNotFoundProblem(ctx, sel, obj)
	case model.VersionMismatchProblem:
		return ec._VersionMismatchProblem(ctx, sel, &obj)
	case *model.VersionMismatchProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._VersionMismatchProblem(ctx, sel, obj)
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.TagUpdateOk:
		return ec._TagUpdateOk(ctx, sel, &obj)
	case *model.TagUpdateOk:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagUpdateOk(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TotalCountResolvingResult(ctx context.Context, sel ast.SelectionSet, obj model.TotalCountResolvingResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.InternalErrorProblem:
		return ec._InternalErrorProblem(ctx, sel, &obj)
	case *model.InternalErrorProblem:
		if obj == nil {
			return graphql.Null
		}
		return ec._InternalErrorProblem(ctx, sel, obj)
	case model.TotalCount:
		return ec._TotalCount(ctx, sel, &obj)
	case *model.TotalCount:
		if obj == nil {
			return graphql.Null
		}
		return ec._TotalCount(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _VersionInterface(ctx context.Context, sel ast.SelectionSet, obj model.VersionInterface) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ArticleBlockHTML:
		return ec._ArticleBlockHtml(ctx, sel, &obj)
	case *model.ArticleBlockHTML:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockHtml(ctx, sel, obj)
	case model.ArticleBlockImage:
		return ec._ArticleBlockImage(ctx, sel, &obj)
	case *model.ArticleBlockImage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleBlockImage(ctx, sel, obj)
	case model.Article:
		return ec._Article(ctx, sel, &obj)
	case *model.Article:
		if obj == nil {
			return graphql.Null
		}
		return ec._Article(ctx, sel, obj)
	case model.ArticleTag:
		return ec._ArticleTag(ctx, sel, &obj)
	case *model.ArticleTag:
		if obj == nil {
			return graphql.Null
		}
		return ec._ArticleTag(ctx, sel, obj)
	case model.Image:
		return ec._Image(ctx, sel, &obj)
	case *model.Image:
		if obj == nil {
			return graphql.Null
		}
		return ec._Image(ctx, sel, obj)
	case model.Project:
		return ec._Project(ctx, sel, &obj)
	case *model.Project:
		if obj == nil {
			return graphql.Null
		}
		return ec._Project(ctx, sel, obj)
	case model.Tag:
		return ec._Tag(ctx, sel, &obj)
	case *model.Tag:
		if obj == nil {
			return graphql.Null
		}
		return ec._Tag(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var articleImplementors = []string{"Article", "VersionInterface"}

func (ec *executionContext) _Article(ctx context.Context, sel ast.SelectionSet, obj *model.Article) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Article")
		case "content":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Article_content(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "coverImage":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Article_coverImage(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "coverImageId":
			out.Values[i] = ec._Article_coverImageId(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Article_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._Article_deletedAt(ctx, field, obj)
		case "id":
			out.Values[i] = ec._Article_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "modifiedAt":
			out.Values[i] = ec._Article_modifiedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Article_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectId":
			out.Values[i] = ec._Article_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Article_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "title":
			out.Values[i] = ec._Article_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._Article_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockCreateOkImplementors = []string{"ArticleBlockCreateOk", "ArticleBlockCreateResult"}

func (ec *executionContext) _ArticleBlockCreateOk(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockCreateOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockCreateOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockCreateOk")
		case "articleBlock":
			out.Values[i] = ec._ArticleBlockCreateOk_articleBlock(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockFindListImplementors = []string{"ArticleBlockFindList", "ArticleBlockFindResult"}

func (ec *executionContext) _ArticleBlockFindList(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockFindList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockFindListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockFindList")
		case "items":
			out.Values[i] = ec._ArticleBlockFindList_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "totalCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleBlockFindList_totalCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockHtmlImplementors = []string{"ArticleBlockHtml", "ArticleBlockInterface", "VersionInterface"}

func (ec *executionContext) _ArticleBlockHtml(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockHTML) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockHtmlImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockHtml")
		case "createdAt":
			out.Values[i] = ec._ArticleBlockHtml_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ArticleBlockHtml_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._ArticleBlockHtml_deletedAt(ctx, field, obj)
		case "id":
			out.Values[i] = ec._ArticleBlockHtml_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "modifiedAt":
			out.Values[i] = ec._ArticleBlockHtml_modifiedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sortRank":
			out.Values[i] = ec._ArticleBlockHtml_sortRank(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ArticleBlockHtml_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockHtmlDataImplementors = []string{"ArticleBlockHtmlData"}

func (ec *executionContext) _ArticleBlockHtmlData(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockHTMLData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockHtmlDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockHtmlData")
		case "body":
			out.Values[i] = ec._ArticleBlockHtmlData_body(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockImageImplementors = []string{"ArticleBlockImage", "ArticleBlockInterface", "VersionInterface"}

func (ec *executionContext) _ArticleBlockImage(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockImage")
		case "createdAt":
			out.Values[i] = ec._ArticleBlockImage_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._ArticleBlockImage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._ArticleBlockImage_deletedAt(ctx, field, obj)
		case "id":
			out.Values[i] = ec._ArticleBlockImage_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "modifiedAt":
			out.Values[i] = ec._ArticleBlockImage_modifiedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sortRank":
			out.Values[i] = ec._ArticleBlockImage_sortRank(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ArticleBlockImage_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockImageDataImplementors = []string{"ArticleBlockImageData"}

func (ec *executionContext) _ArticleBlockImageData(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockImageData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockImageDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockImageData")
		case "image":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleBlockImageData_image(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "imageId":
			out.Values[i] = ec._ArticleBlockImageData_imageId(ctx, field, obj)
		case "copyright":
			out.Values[i] = ec._ArticleBlockImageData_copyright(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ArticleBlockImageData_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockMoveOkImplementors = []string{"ArticleBlockMoveOk", "ArticleBlockMoveResult"}

func (ec *executionContext) _ArticleBlockMoveOk(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockMoveOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockMoveOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockMoveOk")
		case "sortRank":
			out.Values[i] = ec._ArticleBlockMoveOk_sortRank(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ArticleBlockMoveOk_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockMutationImplementors = []string{"ArticleBlockMutation"}

func (ec *executionContext) _ArticleBlockMutation(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockMutation")
		case "create":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleBlockMutation_create(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "move":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleBlockMutation_move(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "update":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleBlockMutation_update(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockNotFoundProblemImplementors = []string{"ArticleBlockNotFoundProblem", "ProblemInterface", "ArticleBlockMoveResult", "ArticleBlockUpdateResult"}

func (ec *executionContext) _ArticleBlockNotFoundProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockNotFoundProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockNotFoundProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockNotFoundProblem")
		case "message":
			out.Values[i] = ec._ArticleBlockNotFoundProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockQueryImplementors = []string{"ArticleBlockQuery"}

func (ec *executionContext) _ArticleBlockQuery(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockQuery")
		case "find":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleBlockQuery_find(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockTypeMismatchProblemImplementors = []string{"ArticleBlockTypeMismatchProblem", "ProblemInterface", "ArticleBlockUpdateResult"}

func (ec *executionContext) _ArticleBlockTypeMismatchProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockTypeMismatchProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockTypeMismatchProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockTypeMismatchProblem")
		case "message":
			out.Values[i] = ec._ArticleBlockTypeMismatchProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleBlockUpdateOkImplementors = []string{"ArticleBlockUpdateOk", "ArticleBlockUpdateResult"}

func (ec *executionContext) _ArticleBlockUpdateOk(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleBlockUpdateOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleBlockUpdateOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleBlockUpdateOk")
		case "articleBlock":
			out.Values[i] = ec._ArticleBlockUpdateOk_articleBlock(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleContentImplementors = []string{"ArticleContent", "ArticleContentResolvingResult"}

func (ec *executionContext) _ArticleContent(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleContent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleContentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleContent")
		case "blocks":
			out.Values[i] = ec._ArticleContent_blocks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleCreateOkImplementors = []string{"ArticleCreateOk", "ArticleCreateResult"}

func (ec *executionContext) _ArticleCreateOk(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleCreateOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleCreateOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleCreateOk")
		case "article":
			out.Values[i] = ec._ArticleCreateOk_article(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleFindListImplementors = []string{"ArticleFindList", "ArticleFindResult"}

func (ec *executionContext) _ArticleFindList(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleFindList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleFindListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleFindList")
		case "items":
			out.Values[i] = ec._ArticleFindList_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "totalCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleFindList_totalCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleMutationImplementors = []string{"ArticleMutation"}

func (ec *executionContext) _ArticleMutation(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleMutation")
		case "create":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleMutation_create(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "update":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleMutation_update(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleNotFoundProblemImplementors = []string{"ArticleNotFoundProblem", "ProblemInterface", "ArticleBlockCreateResult", "ArticleUpdateResult", "ArticleTagCreateResult"}

func (ec *executionContext) _ArticleNotFoundProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleNotFoundProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleNotFoundProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleNotFoundProblem")
		case "message":
			out.Values[i] = ec._ArticleNotFoundProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleQueryImplementors = []string{"ArticleQuery"}

func (ec *executionContext) _ArticleQuery(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleQuery")
		case "find":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleQuery_find(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleTagImplementors = []string{"ArticleTag", "VersionInterface"}

func (ec *executionContext) _ArticleTag(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleTag")
		case "articleID":
			out.Values[i] = ec._ArticleTag_articleID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._ArticleTag_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._ArticleTag_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "modifiedAt":
			out.Values[i] = ec._ArticleTag_modifiedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sortRank":
			out.Values[i] = ec._ArticleTag_sortRank(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tag":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleTag_tag(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tagId":
			out.Values[i] = ec._ArticleTag_tagId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._ArticleTag_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleTagAlreadyExistsProblemImplementors = []string{"ArticleTagAlreadyExistsProblem", "ProblemInterface", "ArticleTagCreateResult"}

func (ec *executionContext) _ArticleTagAlreadyExistsProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleTagAlreadyExistsProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleTagAlreadyExistsProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleTagAlreadyExistsProblem")
		case "message":
			out.Values[i] = ec._ArticleTagAlreadyExistsProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleTagCreateOkImplementors = []string{"ArticleTagCreateOk", "ArticleTagCreateResult"}

func (ec *executionContext) _ArticleTagCreateOk(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleTagCreateOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleTagCreateOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleTagCreateOk")
		case "articleTag":
			out.Values[i] = ec._ArticleTagCreateOk_articleTag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleTagListImplementors = []string{"ArticleTagList", "ArticleTagsResolvingResult"}

func (ec *executionContext) _ArticleTagList(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleTagList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleTagListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleTagList")
		case "items":
			out.Values[i] = ec._ArticleTagList_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleTagMoveOkImplementors = []string{"ArticleTagMoveOk", "ArticleTagMoveResult"}

func (ec *executionContext) _ArticleTagMoveOk(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleTagMoveOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleTagMoveOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleTagMoveOk")
		case "sortRank":
			out.Values[i] = ec._ArticleTagMoveOk_sortRank(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ArticleTagMoveOk_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleTagMutationImplementors = []string{"ArticleTagMutation"}

func (ec *executionContext) _ArticleTagMutation(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleTagMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleTagMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleTagMutation")
		case "create":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleTagMutation_create(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "move":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ArticleTagMutation_move(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleTagNotFoundProblemImplementors = []string{"ArticleTagNotFoundProblem", "ProblemInterface", "ArticleTagMoveResult"}

func (ec *executionContext) _ArticleTagNotFoundProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleTagNotFoundProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleTagNotFoundProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleTagNotFoundProblem")
		case "message":
			out.Values[i] = ec._ArticleTagNotFoundProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var articleUpdateOkImplementors = []string{"ArticleUpdateOk", "ArticleUpdateResult"}

func (ec *executionContext) _ArticleUpdateOk(ctx context.Context, sel ast.SelectionSet, obj *model.ArticleUpdateOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, articleUpdateOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArticleUpdateOk")
		case "article":
			out.Values[i] = ec._ArticleUpdateOk_article(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageImplementors = []string{"Image", "VersionInterface", "ImageResolvingResult"}

func (ec *executionContext) _Image(ctx context.Context, sel ast.SelectionSet, obj *model.Image) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Image")
		case "assets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_assets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Image_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._Image_deletedAt(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Image_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "height":
			out.Values[i] = ec._Image_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._Image_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "modifiedAt":
			out.Values[i] = ec._Image_modifiedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "download":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_download(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "version":
			out.Values[i] = ec._Image_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "width":
			out.Values[i] = ec._Image_width(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageAssetImplementors = []string{"ImageAsset"}

func (ec *executionContext) _ImageAsset(ctx context.Context, sel ast.SelectionSet, obj *model.ImageAsset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageAssetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageAsset")
		case "format":
			out.Values[i] = ec._ImageAsset_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "width":
			out.Values[i] = ec._ImageAsset_width(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._ImageAsset_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageDownloadImplementors = []string{"ImageDownload", "ImageDownloadResolvingResult"}

func (ec *executionContext) _ImageDownload(ctx context.Context, sel ast.SelectionSet, obj *model.ImageDownload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageDownloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageDownload")
		case "url":
			out.Values[i] = ec._ImageDownload_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageFindListImplementors = []string{"ImageFindList", "ImageFindResult"}

func (ec *executionContext) _ImageFindList(ctx context.Context, sel ast.SelectionSet, obj *model.ImageFindList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageFindListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageFindList")
		case "items":
			out.Values[i] = ec._ImageFindList_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "totalCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImageFindList_totalCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageMutationImplementors = []string{"ImageMutation"}

func (ec *executionContext) _ImageMutation(ctx context.Context, sel ast.SelectionSet, obj *model.ImageMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageMutation")
		case "upload":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImageMutation_upload(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageNotFoundProblemImplementors = []string{"ImageNotFoundProblem", "ProblemInterface", "ImageResolvingResult"}

func (ec *executionContext) _ImageNotFoundProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ImageNotFoundProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageNotFoundProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageNotFoundProblem")
		case "message":
			out.Values[i] = ec._ImageNotFoundProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageNotRecognizedProblemImplementors = []string{"ImageNotRecognizedProblem", "ProblemInterface", "ImageUploadResult"}

func (ec *executionContext) _ImageNotRecognizedProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ImageNotRecognizedProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageNotRecognizedProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageNotRecognizedProblem")
		case "message":
			out.Values[i] = ec._ImageNotRecognizedProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageNotSupportedTypeProblemImplementors = []string{"ImageNotSupportedTypeProblem", "ProblemInterface", "ImageUploadResult"}

func (ec *executionContext) _ImageNotSupportedTypeProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ImageNotSupportedTypeProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageNotSupportedTypeProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageNotSupportedTypeProblem")
		case "message":
			out.Values[i] = ec._ImageNotSupportedTypeProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageQueryImplementors = []string{"ImageQuery"}

func (ec *executionContext) _ImageQuery(ctx context.Context, sel ast.SelectionSet, obj *model.ImageQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageQuery")
		case "find":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImageQuery_find(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageUploadOkImplementors = []string{"ImageUploadOk", "ImageUploadResult"}

func (ec *executionContext) _ImageUploadOk(ctx context.Context, sel ast.SelectionSet, obj *model.ImageUploadOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageUploadOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageUploadOk")
		case "image":
			out.Values[i] = ec._ImageUploadOk_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var internalErrorProblemImplementors = []string{"InternalErrorProblem", "ArticleContentResolvingResult", "ArticleTagsResolvingResult", "ArticleBlockCreateResult", "ArticleBlockMoveResult", "ArticleBlockUpdateResult", "ArticleBlockFindResult", "ArticleCreateResult", "ArticleUpdateResult", "ArticleFindResult", "ArticleTagCreateResult", "ArticleTagMoveResult", "ImageResolvingResult", "ImageDownloadResolvingResult", "ImageUploadResult", "ImageFindResult", "ProblemInterface", "ProjectResolvingResult", "ProjectCreateResult", "ProjectUpdateResult", "ProjectFindResult", "TagResolvingResult", "TagCreateResult", "TagUpdateResult", "TagFindResult", "TotalCountResolvingResult"}

func (ec *executionContext) _InternalErrorProblem(ctx context.Context, sel ast.SelectionSet, obj *model.InternalErrorProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, internalErrorProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InternalErrorProblem")
		case "message":
			out.Values[i] = ec._InternalErrorProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invalidSortRankProblemImplementors = []string{"InvalidSortRankProblem", "ArticleBlockCreateResult", "ArticleBlockMoveResult", "ArticleTagCreateResult", "ArticleTagMoveResult", "ProblemInterface"}

func (ec *executionContext) _InvalidSortRankProblem(ctx context.Context, sel ast.SelectionSet, obj *model.InvalidSortRankProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invalidSortRankProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvalidSortRankProblem")
		case "message":
			out.Values[i] = ec._InvalidSortRankProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "articleBlock":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_articleBlock(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "article":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_article(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "articleTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_articleTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "image":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_image(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_project(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_tag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectImplementors = []string{"Project", "VersionInterface", "ProjectResolvingResult"}

func (ec *executionContext) _Project(ctx context.Context, sel ast.SelectionSet, obj *model.Project) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Project")
		case "createdAt":
			out.Values[i] = ec._Project_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Project_deletedAt(ctx, field, obj)
		case "id":
			out.Values[i] = ec._Project_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "modifiedAt":
			out.Values[i] = ec._Project_modifiedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Project_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Project_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectAlreadyExistsProblemImplementors = []string{"ProjectAlreadyExistsProblem", "ProblemInterface", "ProjectCreateResult"}

func (ec *executionContext) _ProjectAlreadyExistsProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ProjectAlreadyExistsProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectAlreadyExistsProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectAlreadyExistsProblem")
		case "message":
			out.Values[i] = ec._ProjectAlreadyExistsProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectCreateOkImplementors = []string{"ProjectCreateOk", "ProjectCreateResult"}

func (ec *executionContext) _ProjectCreateOk(ctx context.Context, sel ast.SelectionSet, obj *model.ProjectCreateOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectCreateOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectCreateOk")
		case "project":
			out.Values[i] = ec._ProjectCreateOk_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectFindListImplementors = []string{"ProjectFindList", "ProjectFindResult"}

func (ec *executionContext) _ProjectFindList(ctx context.Context, sel ast.SelectionSet, obj *model.ProjectFindList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectFindListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectFindList")
		case "items":
			out.Values[i] = ec._ProjectFindList_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "totalCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectFindList_totalCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectMutationImplementors = []string{"ProjectMutation"}

func (ec *executionContext) _ProjectMutation(ctx context.Context, sel ast.SelectionSet, obj *model.ProjectMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectMutation")
		case "create":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectMutation_create(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "update":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectMutation_update(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectNotFoundProblemImplementors = []string{"ProjectNotFoundProblem", "ArticleCreateResult", "ProblemInterface", "ProjectResolvingResult", "ProjectUpdateResult"}

func (ec *executionContext) _ProjectNotFoundProblem(ctx context.Context, sel ast.SelectionSet, obj *model.ProjectNotFoundProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectNotFoundProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectNotFoundProblem")
		case "message":
			out.Values[i] = ec._ProjectNotFoundProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectQueryImplementors = []string{"ProjectQuery"}

func (ec *executionContext) _ProjectQuery(ctx context.Context, sel ast.SelectionSet, obj *model.ProjectQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectQuery")
		case "find":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectQuery_find(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectUpdateOkImplementors = []string{"ProjectUpdateOk", "ProjectUpdateResult"}

func (ec *executionContext) _ProjectUpdateOk(ctx context.Context, sel ast.SelectionSet, obj *model.ProjectUpdateOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectUpdateOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectUpdateOk")
		case "project":
			out.Values[i] = ec._ProjectUpdateOk_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "articleBlock":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_articleBlock(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "article":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_article(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "image":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_image(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_project(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tag":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tag(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "articleBlockCreated":
		return ec._Subscription_articleBlockCreated(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var tagImplementors = []string{"Tag", "VersionInterface", "TagResolvingResult"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *model.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "createdAt":
			out.Values[i] = ec._Tag_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Tag_deletedAt(ctx, field, obj)
		case "id":
			out.Values[i] = ec._Tag_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "modifiedAt":
			out.Values[i] = ec._Tag_modifiedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Tag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Tag_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagAlreadyExistsProblemImplementors = []string{"TagAlreadyExistsProblem", "ProblemInterface", "TagCreateResult"}

func (ec *executionContext) _TagAlreadyExistsProblem(ctx context.Context, sel ast.SelectionSet, obj *model.TagAlreadyExistsProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagAlreadyExistsProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagAlreadyExistsProblem")
		case "message":
			out.Values[i] = ec._TagAlreadyExistsProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagCreateOkImplementors = []string{"TagCreateOk", "TagCreateResult"}

func (ec *executionContext) _TagCreateOk(ctx context.Context, sel ast.SelectionSet, obj *model.TagCreateOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagCreateOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagCreateOk")
		case "tag":
			out.Values[i] = ec._TagCreateOk_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagFindListImplementors = []string{"TagFindList", "TagFindResult"}

func (ec *executionContext) _TagFindList(ctx context.Context, sel ast.SelectionSet, obj *model.TagFindList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagFindListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagFindList")
		case "items":
			out.Values[i] = ec._TagFindList_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "totalCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TagFindList_totalCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagMutationImplementors = []string{"TagMutation"}

func (ec *executionContext) _TagMutation(ctx context.Context, sel ast.SelectionSet, obj *model.TagMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagMutation")
		case "create":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TagMutation_create(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "update":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TagMutation_update(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagNotFoundProblemImplementors = []string{"TagNotFoundProblem", "ArticleTagCreateResult", "ProblemInterface", "TagResolvingResult", "TagUpdateResult"}

func (ec *executionContext) _TagNotFoundProblem(ctx context.Context, sel ast.SelectionSet, obj *model.TagNotFoundProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagNotFoundProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagNotFoundProblem")
		case "message":
			out.Values[i] = ec._TagNotFoundProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagQueryImplementors = []string{"TagQuery"}

func (ec *executionContext) _TagQuery(ctx context.Context, sel ast.SelectionSet, obj *model.TagQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagQuery")
		case "find":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TagQuery_find(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagUpdateOkImplementors = []string{"TagUpdateOk", "TagUpdateResult"}

func (ec *executionContext) _TagUpdateOk(ctx context.Context, sel ast.SelectionSet, obj *model.TagUpdateOk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagUpdateOkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagUpdateOk")
		case "tag":
			out.Values[i] = ec._TagUpdateOk_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var totalCountImplementors = []string{"TotalCount", "TotalCountResolvingResult"}

func (ec *executionContext) _TotalCount(ctx context.Context, sel ast.SelectionSet, obj *model.TotalCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, totalCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TotalCount")
		case "value":
			out.Values[i] = ec._TotalCount_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionMismatchProblemImplementors = []string{"VersionMismatchProblem", "ArticleBlockMoveResult", "ArticleBlockUpdateResult", "ArticleUpdateResult", "ArticleTagMoveResult", "ProjectUpdateResult", "TagUpdateResult", "ProblemInterface"}

func (ec *executionContext) _VersionMismatchProblem(ctx context.Context, sel ast.SelectionSet, obj *model.VersionMismatchProblem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionMismatchProblemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionMismatchProblem")
		case "message":
			out.Values[i] = ec._VersionMismatchProblem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNArticle2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Article) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNArticle2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNArticle2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticle(ctx context.Context, sel ast.SelectionSet, v *model.Article) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Article(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArticleBlockCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockCreateInput(ctx context.Context, v interface{}) (model.ArticleBlockCreateInput, error) {
	res, err := ec.unmarshalInputArticleBlockCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleBlockCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockCreateResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleBlockCreateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleBlockCreateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArticleBlockDataInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockDataInput(ctx context.Context, v interface{}) (*model.ArticleBlockDataInput, error) {
	res, err := ec.unmarshalInputArticleBlockDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleBlockFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockFindResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleBlockFindResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleBlockFindResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArticleBlockFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockFindSortEnum(ctx context.Context, v interface{}) (model.ArticleBlockFindSortEnum, error) {
	var res model.ArticleBlockFindSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleBlockFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockFindSortEnum(ctx context.Context, sel ast.SelectionSet, v model.ArticleBlockFindSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNArticleBlockHtmlData2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockHTMLData(ctx context.Context, sel ast.SelectionSet, v *model.ArticleBlockHTMLData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleBlockHtmlData(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleBlockImageData2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockImageData(ctx context.Context, sel ast.SelectionSet, v *model.ArticleBlockImageData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleBlockImageData(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleBlockInterface2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockInterface(ctx context.Context, sel ast.SelectionSet, v model.ArticleBlockInterface) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleBlockInterface(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleBlockInterface2ᚕgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockInterfaceᚄ(ctx context.Context, sel ast.SelectionSet, v []model.ArticleBlockInterface) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNArticleBlockInterface2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNArticleBlockMoveInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockMoveInput(ctx context.Context, v interface{}) (model.ArticleBlockMoveInput, error) {
	res, err := ec.unmarshalInputArticleBlockMoveInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleBlockMoveResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockMoveResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleBlockMoveResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleBlockMoveResult(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleBlockMutation2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockMutation(ctx context.Context, sel ast.SelectionSet, v model.ArticleBlockMutation) graphql.Marshaler {
	return ec._ArticleBlockMutation(ctx, sel, &v)
}

func (ec *executionContext) marshalNArticleBlockMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockMutation(ctx context.Context, sel ast.SelectionSet, v *model.ArticleBlockMutation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleBlockMutation(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleBlockQuery2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockQuery(ctx context.Context, sel ast.SelectionSet, v model.ArticleBlockQuery) graphql.Marshaler {
	return ec._ArticleBlockQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNArticleBlockQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockQuery(ctx context.Context, sel ast.SelectionSet, v *model.ArticleBlockQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleBlockQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArticleBlockTypeEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockTypeEnum(ctx context.Context, v interface{}) (model.ArticleBlockTypeEnum, error) {
	var res model.ArticleBlockTypeEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleBlockTypeEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockTypeEnum(ctx context.Context, sel ast.SelectionSet, v model.ArticleBlockTypeEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNArticleBlockUpdateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockUpdateInput(ctx context.Context, v interface{}) (model.ArticleBlockUpdateInput, error) {
	res, err := ec.unmarshalInputArticleBlockUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleBlockUpdateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleBlockUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleBlockUpdateResult(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleContentResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleContentResolvingResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleContentResolvingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleContentResolvingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArticleCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleCreateInput(ctx context.Context, v interface{}) (model.ArticleCreateInput, error) {
	res, err := ec.unmarshalInputArticleCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleCreateResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleCreateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleCreateResult(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleFindResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleFindResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleFindResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArticleFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleFindSortEnum(ctx context.Context, v interface{}) (model.ArticleFindSortEnum, error) {
	var res model.ArticleFindSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleFindSortEnum(ctx context.Context, sel ast.SelectionSet, v model.ArticleFindSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNArticleMutation2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleMutation(ctx context.Context, sel ast.SelectionSet, v model.ArticleMutation) graphql.Marshaler {
	return ec._ArticleMutation(ctx, sel, &v)
}

func (ec *executionContext) marshalNArticleMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleMutation(ctx context.Context, sel ast.SelectionSet, v *model.ArticleMutation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleMutation(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleQuery2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleQuery(ctx context.Context, sel ast.SelectionSet, v model.ArticleQuery) graphql.Marshaler {
	return ec._ArticleQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNArticleQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleQuery(ctx context.Context, sel ast.SelectionSet, v *model.ArticleQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleQuery(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleTag2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ArticleTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNArticleTag2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNArticleTag2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTag(ctx context.Context, sel ast.SelectionSet, v *model.ArticleTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArticleTagCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagCreateInput(ctx context.Context, v interface{}) (model.ArticleTagCreateInput, error) {
	res, err := ec.unmarshalInputArticleTagCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleTagCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagCreateResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleTagCreateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleTagCreateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArticleTagMoveInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagMoveInput(ctx context.Context, v interface{}) (model.ArticleTagMoveInput, error) {
	res, err := ec.unmarshalInputArticleTagMoveInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleTagMoveResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagMoveResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleTagMoveResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleTagMoveResult(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleTagMutation2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagMutation(ctx context.Context, sel ast.SelectionSet, v model.ArticleTagMutation) graphql.Marshaler {
	return ec._ArticleTagMutation(ctx, sel, &v)
}

func (ec *executionContext) marshalNArticleTagMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagMutation(ctx context.Context, sel ast.SelectionSet, v *model.ArticleTagMutation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleTagMutation(ctx, sel, v)
}

func (ec *executionContext) marshalNArticleTagsResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleTagsResolvingResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleTagsResolvingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleTagsResolvingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArticleUpdateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleUpdateInput(ctx context.Context, v interface{}) (model.ArticleUpdateInput, error) {
	res, err := ec.unmarshalInputArticleUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArticleUpdateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.ArticleUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArticleUpdateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNHtml2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHtml2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNImage2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Image) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImage2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImage2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImage(ctx context.Context, sel ast.SelectionSet, v *model.Image) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Image(ctx, sel, v)
}

func (ec *executionContext) marshalNImageAsset2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAssetᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ImageAsset) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageAsset2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAsset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImageAsset2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAsset(ctx context.Context, sel ast.SelectionSet, v *model.ImageAsset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageAsset(ctx, sel, v)
}

func (ec *executionContext) unmarshalNImageAssetFormat2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAssetFormat(ctx context.Context, v interface{}) (model.ImageAssetFormat, error) {
	var res model.ImageAssetFormat
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageAssetFormat2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAssetFormat(ctx context.Context, sel ast.SelectionSet, v model.ImageAssetFormat) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNImageAssetWidth2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAssetWidth(ctx context.Context, v interface{}) (model.ImageAssetWidth, error) {
	var res model.ImageAssetWidth
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageAssetWidth2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageAssetWidth(ctx context.Context, sel ast.SelectionSet, v model.ImageAssetWidth) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNImageDownloadResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageDownloadResolvingResult(ctx context.Context, sel ast.SelectionSet, v model.ImageDownloadResolvingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageDownloadResolvingResult(ctx, sel, v)
}

func (ec *executionContext) marshalNImageFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageFindResult(ctx context.Context, sel ast.SelectionSet, v model.ImageFindResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageFindResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNImageFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageFindSortEnum(ctx context.Context, v interface{}) (model.ImageFindSortEnum, error) {
	var res model.ImageFindSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageFindSortEnum(ctx context.Context, sel ast.SelectionSet, v model.ImageFindSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNImageMutation2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageMutation(ctx context.Context, sel ast.SelectionSet, v model.ImageMutation) graphql.Marshaler {
	return ec._ImageMutation(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageMutation(ctx context.Context, sel ast.SelectionSet, v *model.ImageMutation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageMutation(ctx, sel, v)
}

func (ec *executionContext) marshalNImageQuery2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageQuery(ctx context.Context, sel ast.SelectionSet, v model.ImageQuery) graphql.Marshaler {
	return ec._ImageQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageQuery(ctx context.Context, sel ast.SelectionSet, v *model.ImageQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageQuery(ctx, sel, v)
}

func (ec *executionContext) marshalNImageResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageResolvingResult(ctx context.Context, sel ast.SelectionSet, v model.ImageResolvingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageResolvingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNImageUploadInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageUploadInput(ctx context.Context, v interface{}) (model.ImageUploadInput, error) {
	res, err := ec.unmarshalInputImageUploadInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageUploadResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageUploadResult(ctx context.Context, sel ast.SelectionSet, v model.ImageUploadResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageUploadResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPageNumber2uint(ctx context.Context, v interface{}) (uint, error) {
	res, err := model.UnmarshalPageNumber(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPageNumber2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := model.MarshalPageNumber(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNPageSize2uint(ctx context.Context, v interface{}) (uint, error) {
	res, err := model.UnmarshalPageSize(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPageSize2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := model.MarshalPageSize(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNProject2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Project) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProject2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProject(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProject2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProject(ctx context.Context, sel ast.SelectionSet, v *model.Project) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectCreateInput(ctx context.Context, v interface{}) (model.ProjectCreateInput, error) {
	res, err := ec.unmarshalInputProjectCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectCreateResult(ctx context.Context, sel ast.SelectionSet, v model.ProjectCreateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectCreateResult(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectFindResult(ctx context.Context, sel ast.SelectionSet, v model.ProjectFindResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectFindResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectFindSortEnum(ctx context.Context, v interface{}) (model.ProjectFindSortEnum, error) {
	var res model.ProjectFindSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectFindSortEnum(ctx context.Context, sel ast.SelectionSet, v model.ProjectFindSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProjectMutation2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectMutation(ctx context.Context, sel ast.SelectionSet, v model.ProjectMutation) graphql.Marshaler {
	return ec._ProjectMutation(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectMutation(ctx context.Context, sel ast.SelectionSet, v *model.ProjectMutation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectMutation(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectQuery2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectQuery(ctx context.Context, sel ast.SelectionSet, v model.ProjectQuery) graphql.Marshaler {
	return ec._ProjectQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectQuery(ctx context.Context, sel ast.SelectionSet, v *model.ProjectQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectQuery(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectResolvingResult(ctx context.Context, sel ast.SelectionSet, v model.ProjectResolvingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectResolvingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectUpdateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectUpdateInput(ctx context.Context, v interface{}) (model.ProjectUpdateInput, error) {
	res, err := ec.unmarshalInputProjectUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectUpdateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.ProjectUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectUpdateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRfc3339Date2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := model.UnmarshalRfc3339Date(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRfc3339Date2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := model.MarshalRfc3339Date(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNSortRankInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐSortRankInput(ctx context.Context, v interface{}) (*model.SortRankInput, error) {
	res, err := ec.unmarshalInputSortRankInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTag2ᚕᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTag(ctx context.Context, sel ast.SelectionSet, v *model.Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTagCreateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagCreateInput(ctx context.Context, v interface{}) (model.TagCreateInput, error) {
	res, err := ec.unmarshalInputTagCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagCreateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagCreateResult(ctx context.Context, sel ast.SelectionSet, v model.TagCreateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagCreateResult(ctx, sel, v)
}

func (ec *executionContext) marshalNTagFindResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagFindResult(ctx context.Context, sel ast.SelectionSet, v model.TagFindResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagFindResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTagFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagFindSortEnum(ctx context.Context, v interface{}) (model.TagFindSortEnum, error) {
	var res model.TagFindSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagFindSortEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagFindSortEnum(ctx context.Context, sel ast.SelectionSet, v model.TagFindSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTagMutation2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagMutation(ctx context.Context, sel ast.SelectionSet, v model.TagMutation) graphql.Marshaler {
	return ec._TagMutation(ctx, sel, &v)
}

func (ec *executionContext) marshalNTagMutation2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagMutation(ctx context.Context, sel ast.SelectionSet, v *model.TagMutation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagMutation(ctx, sel, v)
}

func (ec *executionContext) marshalNTagQuery2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagQuery(ctx context.Context, sel ast.SelectionSet, v model.TagQuery) graphql.Marshaler {
	return ec._TagQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNTagQuery2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagQuery(ctx context.Context, sel ast.SelectionSet, v *model.TagQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagQuery(ctx, sel, v)
}

func (ec *executionContext) marshalNTagResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagResolvingResult(ctx context.Context, sel ast.SelectionSet, v model.TagResolvingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagResolvingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTagUpdateInput2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagUpdateInput(ctx context.Context, v interface{}) (model.TagUpdateInput, error) {
	res, err := ec.unmarshalInputTagUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagUpdateResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.TagUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagUpdateResult(ctx, sel, v)
}

func (ec *executionContext) marshalNTotalCountResolvingResult2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTotalCountResolvingResult(ctx context.Context, sel ast.SelectionSet, v model.TotalCountResolvingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TotalCountResolvingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUInt2uint(ctx context.Context, v interface{}) (uint, error) {
	res, err := model.UnmarshalUInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUInt2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := model.MarshalUInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUrl2netᚋurlᚐURL(ctx context.Context, v interface{}) (url.URL, error) {
	res, err := model.UnmarshalUrl(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUrl2netᚋurlᚐURL(ctx context.Context, sel ast.SelectionSet, v url.URL) graphql.Marshaler {
	res := model.MarshalUrl(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	res, err := model.UnmarshalUuid(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	res := model.MarshalUuid(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOArticleBlockFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockFindFilterInput(ctx context.Context, v interface{}) (*model.ArticleBlockFindFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputArticleBlockFindFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOArticleBlockHtmlDataInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockHTMLDataInput(ctx context.Context, v interface{}) (*model.ArticleBlockHTMLDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputArticleBlockHtmlDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOArticleBlockImageDataInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockImageDataInput(ctx context.Context, v interface{}) (*model.ArticleBlockImageDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputArticleBlockImageDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOArticleBlockTypeEnum2ᚕgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockTypeEnumᚄ(ctx context.Context, v interface{}) ([]model.ArticleBlockTypeEnum, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.ArticleBlockTypeEnum, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNArticleBlockTypeEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockTypeEnum(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOArticleBlockTypeEnum2ᚕgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockTypeEnumᚄ(ctx context.Context, sel ast.SelectionSet, v []model.ArticleBlockTypeEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNArticleBlockTypeEnum2githubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleBlockTypeEnum(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOArticleFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐArticleFindFilterInput(ctx context.Context, v interface{}) (*model.ArticleFindFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputArticleFindFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOHtml2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHtml2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOImageFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐImageFindFilterInput(ctx context.Context, v interface{}) (*model.ImageFindFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputImageFindFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProjectFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐProjectFindFilterInput(ctx context.Context, v interface{}) (*model.ProjectFindFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectFindFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORfc3339Date2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalRfc3339Date(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORfc3339Date2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := model.MarshalRfc3339Date(*v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTagFindFilterInput2ᚖgithubᚗcomᚋacelotᚋarticlesᚋinternalᚋgqlᚋmodelᚐTagFindFilterInput(ctx context.Context, v interface{}) (*model.TagFindFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTagFindFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpload2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, v interface{}) (*graphql.Upload, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUpload(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpload2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, sel ast.SelectionSet, v *graphql.Upload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUpload(*v)
	return res
}

func (ec *executionContext) unmarshalOUuid2ᚕgithubᚗcomᚋgoogleᚋuuidᚐUUIDᚄ(ctx context.Context, v interface{}) ([]uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]uuid.UUID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUuid2ᚕgithubᚗcomᚋgoogleᚋuuidᚐUUIDᚄ(ctx context.Context, sel ast.SelectionSet, v []uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUuid2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUuid2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, v interface{}) (*uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalUuid(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUuid2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v *uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := model.MarshalUuid(*v)
	return res
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
